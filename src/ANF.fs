// hyggec - The didactic compiler for the Hygge programming language.
// Copyright (C) 2023 Technical University of Denmark
// Author: Alceste Scalas <alcsc@dtu.dk>
// Released under the MIT license (see LICENSE.md for details)

/// Transformation of a program AST into Administrative Normal Form.
module ANF

open AST


/// ANF definition: a variable name with a boolean mutability boolean flag, and
/// the AST node (expected to be in ANF) that initialises the variable.
type internal ANFDef<'E,'T>(var: string, isRecursive: bool, isMutable: bool, init: Node<'E,'T>, pretype: PretypeNode option) =
    /// Variable introduced by this ANF definition.
    member this.Var = var
    /// Is this ANF definition introducing a recursive lambda?
    member this.IsRecursive = isRecursive
    /// Is this ANF definition introducing a mutable variable?
    member this.IsMutable = isMutable
    /// Initialisation expression (in ANF) of this ANF definition.
    member this.Init = init
    /// Pretype of the variable, if any.
    member this.Pretype = pretype

    /// Construct an ANF definition with an autogenerated unique variable name.
    new(isMutable: bool, init: Node<'E,'T>) =
        ANFDef(Util.genSymbol "$anf", false, isMutable, init, None)


/// List of ANF definitions.
type internal ANFDefs<'E,'T> = List<ANFDef<'E,'T>>


/// Utility function to generate a unique variable name for binding ANF definitions.
let internal anfVar() = Util.genSymbol "$anf"


/// Given the AST 'node', return a new AST node where every free occurrence of
/// the variable called 'var' is substituted by variable 'var2'.
let rec substVar (node: Node<'E,'T>) (var: string) (var2: string): Node<'E,'T> =
    match node.Expr with
    | UnitVal
    | IntVal _
    | BoolVal _
    | FloatVal _
    | StringVal _ -> node // The substitution has no effect

    | Pointer _ -> node // The substitution has no effect

    | Var(vname) when vname = var -> {node with Expr = Var(var2)} // Substitution applied
    | Var _ -> node // The substitution has no effect

    | Add(lhs, rhs) ->
        {node with Expr = Add((substVar lhs var var2), (substVar rhs var var2))}
    | Sub(lhs, rhs) ->
        {node with Expr = Sub((substVar lhs var var2), (substVar rhs var var2))}
    | Mult(lhs, rhs) ->
        {node with Expr = Mult((substVar lhs var var2), (substVar rhs var var2))}

    | And(lhs, rhs) ->
        {node with Expr = And((substVar lhs var var2), (substVar rhs var var2))}
    | Or(lhs, rhs) ->
        {node with Expr = Or((substVar lhs var var2), (substVar rhs var var2))}
    | Not(arg) ->
        {node with Expr = Not(substVar arg var var2)}

    | Eq(lhs, rhs) ->
        {node with Expr = Eq((substVar lhs var var2), (substVar rhs var var2))}
    | Less(lhs, rhs) ->
        {node with Expr = Less((substVar lhs var var2), (substVar rhs var var2))}

    // New addition
    | LessEq(lhs, rhs) ->
        {node with Expr = LessEq((substVar lhs var var2), (substVar rhs var var2))}

    | Greater(lhs, rhs) ->
        {node with Expr = Greater((substVar lhs var var2), (substVar rhs var var2))}
    
    | GreaterEq(lhs, rhs) ->
        {node with Expr = GreaterEq((substVar lhs var var2), (substVar rhs var var2))}

    | Sqrt(arg) ->
        {node with Expr = Sqrt(substVar arg var var2)}

    | Min(lhs, rhs) -> 
        {node with Expr = Min((substVar lhs var var2), (substVar rhs var var2))}
    
    | Max(lhs, rhs) -> 
        {node with Expr = Max((substVar lhs var var2), (substVar rhs var var2))}

    | Div(lhs, rhs) -> 
         {node with Expr = Div((substVar lhs var var2), (substVar rhs var var2))}

    | Mod(lhs, rhs) -> 
         {node with Expr = Mod((substVar lhs var var2), (substVar rhs var var2))}
    
    | ArrayCons(length, init) ->
         {node with Expr = ArrayCons((substVar length var var2), (substVar init var var2))}

    | ArrayLength(target) ->
         {node with Expr = ArrayLength (substVar target var var2)}

    | ArrayElem(target, index) ->
         {node with Expr = ArrayElem((substVar target var var2), (substVar index var var2))}

    | ArraySlice(target, startIdx, endIdx) ->
         {node with Expr = ArraySlice((substVar target var var2), 
                                    (substVar startIdx var var2),
                                    (substVar endIdx var var2))}

    | ReadInt
    | ReadFloat -> node // The substitution has no effect

    | Print(arg) ->
        {node with Expr = Print(substVar arg var var2)}
    | PrintLn(arg) ->
        {node with Expr = PrintLn(substVar arg var var2)}

    | If(cond, ifTrue, ifFalse) ->
        {node with Expr = If((substVar cond var var2), (substVar ifTrue var var2),
                                                       (substVar ifFalse var var2))}

    | Seq(nodes) ->
        let substNodes = List.map (fun n -> (substVar n var var2)) nodes
        {node with Expr = Seq(substNodes)}

    | Ascription(tpe, node) ->
        {node with Expr = Ascription(tpe, (substVar node var var2))}

    | Let(vname, init, scope) when vname = var ->
        // Do not substitute the variable in the "let" scope
        {node with Expr = Let(vname,(substVar init var var2), scope)}
    | Let(vname, init, scope) ->
        {node with Expr = Let(vname, (substVar init var var2),
                              (substVar scope var var2))}

    | LetT(vname, tpe, init, scope) when vname = var ->
        // Do not substitute the variable in the "let" scope
        {node with Expr = LetT(vname, tpe, (substVar init var var2), scope)}
    | LetT(vname, tpe, init, scope) ->
        {node with Expr = LetT(vname, tpe, (substVar init var var2),
                               (substVar scope var var2))}
        
    | LetRec(vname, _, _, _) when vname = var ->
        // The variable is shadowed, do not substitute it in the "let rec" scope
        // and similarly in "let rec" initialisation as it might be recursively defined
        node
    | LetRec(vname, tpe, init, scope) ->
        // Propagate the substitution in the "let rec" scope and init safely
        {node with Expr = LetRec(vname, tpe, (substVar init var var2),
                                 (substVar scope var var2))}

    | LetMut(vname, init, scope) when vname = var ->
        // Do not substitute the variable in the "let mutable" scope
        {node with Expr = LetMut(vname, (substVar init var var2), scope)}
    | LetMut(vname, init, scope) ->
        {node with Expr = LetMut(vname, (substVar init var var2),
                                 (substVar scope var var2))}

    | Assign(target, expr) ->
        {node with Expr = Assign((substVar target var var2), (substVar expr var var2))}
    
    | While(cond, body) ->
        let substCond = substVar cond var var2
        let substBody = substVar body var var2
        {node with Expr = While(substCond, substBody)}

    | DoWhile(body, cond) ->
        let substCond = substVar cond var var2
        let substBody = substVar body var var2
        {node with Expr = DoWhile(substBody, substCond)}

    | Assertion(arg) ->
        {node with Expr = Assertion(substVar arg var var2)}

    | Type(tname, def, scope) ->
        {node with Expr = Type(tname, def, (substVar scope var var2))}

    | Lambda(args, body) ->
        /// Arguments of this lambda term, without their pretypes
        let argVars, _ = List.unzip args
        if (List.contains var argVars) then node // No substitution
        else {node with Expr = Lambda(args, (substVar body var var2))}

    | Application(expr, args) ->
        let substExpr = substVar expr var var2
        let substArgs = List.map (fun n -> (substVar n var var2)) args
        {node with Expr = Application(substExpr, substArgs)}

    | StructCons(fields) ->
        let fieldNames, initNodes = List.unzip fields
        let substInitNodes = List.map (fun e -> (substVar e var var2)) initNodes
        {node with Expr = StructCons(List.zip fieldNames substInitNodes)}

    | FieldSelect(target, field) ->
        {node with Expr = FieldSelect((substVar target var var2), field)}
        
    | Copy arg -> {node with Expr = Copy (substVar arg var var2)}

    | UnionCons(label, expr) ->
        {node with Expr = UnionCons(label, (substVar expr var var2))}

    | Match(expr, cases) ->
        /// Mapper function to propagate the substitution along a match case
        let substCase(lab: string, v: string, cont: Node<'E,'T>) =
            if (v = var) then (lab, v, cont) // Variable bound, no substitution
            else (lab, v, (substVar cont var var2))
        let cases2 = List.map substCase cases
        {node with Expr = Match((substVar expr var var2), cases2)}


/// Convert a given AST node (expected to contain a variable) and a list of ANF
/// definitions (with the most recent at the head of the list) into a
/// corresponding series nested of "let" binders in ANF, having the given AST
/// node in the innermost scope.
let rec internal toANF (node: Node<'E,'T>, defs: ANFDefs<'E,'T>): Node<'E,'T> =
    match defs with
    | [] -> node
    | anfDef :: rest ->
        /// Binder for this ANF definition
        let binder = if anfDef.IsRecursive && anfDef.Pretype.IsSome then
                        LetRec(anfDef.Var, anfDef.Pretype.Value, anfDef.Init, node)
                     else if anfDef.IsMutable then
                        LetMut(anfDef.Var, anfDef.Init, node)
                     else
                        Let(anfDef.Var, anfDef.Init, node)
        toANF ({node with Expr = binder}, rest)


/// Transform the given AST node into a variable, plus a list of ANF definitions
/// --- i.e. the variable names with their definitions (also in ANF) that are
/// required to compute the returned variable. NOTE: the list of definitions is
/// constructed in reverse, with the most recent addition at the front (to
/// improve performance).
let rec internal toANFDefs (node: Node<'E,'T>): Node<'E,'T> * ANFDefs<'E,'T> =
    match node.Expr with
    | UnitVal
    | BoolVal _
    | IntVal _
    | FloatVal _
    | StringVal _ as expr ->
        /// Definition binding this value to a variable
        let anfDef = ANFDef(false, {node with Expr = expr})
        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | Var _ ->
        (node, []) // This AST node is already in ANF

    | Add(lhs, rhs)
    | Sub(lhs, rhs)
    | Mult(lhs, rhs)
    | And(lhs, rhs)
    | Or(lhs, rhs)
    | Eq(lhs, rhs)
    | Less(lhs, rhs)
    | LessEq(lhs, rhs)
    | Greater(lhs, rhs)
    | GreaterEq(lhs, rhs)
    | Min(lhs, rhs)
    | Max(lhs, rhs)
    | Div(lhs, rhs)
    | Mod(lhs, rhs) as expr ->
        /// Left-hand-side argument in ANF and related definitions
        let lhsANF, lhsDefs = toANFDefs lhs
        /// Right-hand-side argument in ANF and related definitions
        let rhsANF, rhsDefs = toANFDefs rhs
        /// This expression in ANF
        let anfExpr = match expr with
                      | Add _ -> Add(lhsANF, rhsANF)
                      | Sub _ -> Sub(lhsANF, rhsANF)
                      | Mult _ -> Mult(lhsANF, rhsANF)
                      | And _ -> And(lhsANF, rhsANF)
                      | Or _ -> Or(lhsANF, rhsANF)
                      | Eq _ -> Eq(lhsANF, rhsANF)
                      | Less _ -> Less(lhsANF, rhsANF)
                      | LessEq _ -> LessEq(lhsANF, rhsANF)
                      | Greater _ -> Greater(lhsANF, rhsANF)
                      | GreaterEq _ -> GreaterEq(lhsANF, rhsANF)
                      | Min _ -> Min(lhsANF, rhsANF)
                      | Max _ -> Max(lhsANF, rhsANF)
                      | Div _ -> Div(lhsANF, rhsANF)
                      | Mod _ -> Mod(lhsANF, rhsANF)
                      | e -> failwith $"BUG: unexpected expression: %O{e}"
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = anfExpr})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: (rhsDefs @ lhsDefs))

    | ReadInt
    | ReadFloat as expr ->
        /// Definition binding this expression to a variable
        let anfDef = ANFDef(false, {node with Expr = expr})
        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | Not(arg)
    | Print(arg)
    | PrintLn(arg)
    | Assertion(arg)
    | Sqrt(arg) as expr ->
        /// Argument in ANF and related definitions
        let argANF, argDefs = toANFDefs arg
        /// This expression in ANF
        let anfExpr = match expr with
                      | Not _ -> Not(argANF)
                      | Print _ -> Print(argANF)
                      | PrintLn _ -> PrintLn(argANF)
                      | Assertion _  -> Assertion(argANF)
                      | Sqrt _ -> Sqrt(argANF)
                      | e -> failwith $"BUG: unexpected expression: %O{e}"
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = anfExpr})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: argDefs)

    | Seq(nodes) ->
        match (List.rev nodes) with
        | [] ->
            failwith $"BUG: empty AST Seq node at %O{node.Pos}"
        | last :: rest ->
            /// Last AST node in the sequence in ANF and related definitions
            let lastANF, lastDefs = toANFDefs last
            /// ANF definitions of the rest of the Seq nodes (in reverse order).
            /// We collect the definitions and ignore the variable bound to each
            /// node of the sequence, because such variable will be unused in
            /// the sequence.
            let restANFDefs = List.collect snd (List.map toANFDefs rest)

            (lastANF, lastDefs @ restANFDefs)

    | Ascription(tpe, arg) ->
        /// Argument in ANF and related definitions
        let argANF, argDefs = toANFDefs arg
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Ascription(tpe, argANF)})
        ({node with Expr = Var(anfDef.Var)}, anfDef :: argDefs)

    | If(condition, ifTrue, ifFalse) ->
        /// Condition in ANF and related definitions
        let condANF, condDefs = toANFDefs condition
        /// True branch in ANF
        let ifTrueANF = toANF (toANFDefs ifTrue)
        /// True branch in ANF
        let ifFalseANF = toANF (toANFDefs ifFalse)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = If(condANF, ifTrueANF, ifFalseANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: condDefs)

    | Let(name, init, scope)
    | LetT(name, _, init, scope)
    | LetMut(name, init, scope) as expr ->
        // ANF requires variable names to be unique, so we rewrite the scope
        /// Variable name bound by this 'let' expression, made unique
        let uniqName = Util.genSymbol name
        /// Rewritten scope with 'name' replaced by 'uniqName'
        let scope = substVar scope name uniqName
        /// Variable name (now made unique) bound by this 'let' expression
        let name = uniqName
        /// Initialization expression in ANF and related definitions
        let initANF, initDefs = match init.Expr with
                                  | UnitVal
                                  | BoolVal _
                                  | IntVal _
                                  | FloatVal _
                                  | StringVal _
                                  | Var _ ->
                                      (init, []) // 'init' is already in ANF
                                  | _ ->
                                      toANFDefs init
        /// Scope expression in ANF and its related definitions
        let scopeANF, scopeDefs  = toANFDefs scope
        /// Mark if the let-binder is mutable
        let isMutable = match expr with
                        | Let _
                        | LetT _-> false
                        | LetMut _ -> true                      
                        | e -> failwith $"BUG: unexpected expression: %O{e}"
        /// Definition binding the "let" variable to the init expression in ANF
        let letDef = ANFDef(name, false, isMutable, initANF, None)

        ({node with Expr = scopeANF.Expr}, scopeDefs @ letDef :: initDefs)
    
    | LetRec(name, tpe, init, scope) ->
        // ANF requires variable names to be unique, so we rewrite the scope
        /// Variable name bound by this recursive 'let' expression, made unique
        let uniqName = Util.genSymbol name
        /// Rewritten scope and initialisation with 'name' replaced by 'uniqName'
        let scope = substVar scope name uniqName
        let init = substVar init name uniqName
        /// Variable name (now made unique) bound by this 'let' expression
        let name = uniqName
        /// Initialization var and definitions in ANF
        let initANF, initDefs = toANFDefs init
        /// Scope var and definitions in ANF
        let scopeANF, scopeDefs  = toANFDefs scope
        /// Recursive `let` binding with ANF components
        let letDef = ANFDef(name, true, false, initANF, Some tpe)
        
        ({node with Expr = scopeANF.Expr}, scopeDefs @ letDef :: initDefs)

    | Assign(target, asgnExpr) ->
        /// Source expression of the assignment in ANF and related definitions
        let asgnExprANF, asgnExprDefs = toANFDefs asgnExpr
        match target.Expr with
        | Var _ ->
            /// Definition binding this expression in ANF to its variable
            let anfDef = ANFDef(false, {node with Expr = Assign(target, asgnExprANF)})
            ({node with Expr = Var(anfDef.Var)}, anfDef :: asgnExprDefs)
        | FieldSelect(ftarget, field) ->
            /// Target expr of the field selection in ANF and related definitions
            let ftargetExprANF, ftargetExprDefs = toANFDefs ftarget
            /// Assignment to field selection in ANF form
            let anfAssign = Assign({target with Expr = FieldSelect(ftargetExprANF, field)}, asgnExprANF)
            /// Definition binding this expression in ANF to its variable
            let anfDef = ANFDef(false, {node with Expr = anfAssign})
            ({node with Expr = Var(anfDef.Var)}, anfDef :: (ftargetExprDefs @ asgnExprDefs))
        | ArrayElem(atarget, index) ->
            /// We also require Assign to handle array elements.
            /// Target array expression in ANF and related definitions
            let atargetANF, atargetDefs = toANFDefs atarget
            /// Index expression in ANF and related definitions
            let indexANF, indexDefs = toANFDefs index
            /// Assignment to array element in ANF form
            let anfAssign = Assign({target with Expr = ArrayElem(atargetANF, indexANF)}, asgnExprANF)
             /// Definition binding this expression in ANF to its variable
            let anfDef = ANFDef(false, {node with Expr = anfAssign})
            ({node with Expr = Var(anfDef.Var)}, anfDef :: (indexDefs @ atargetDefs @ asgnExprDefs))
        | _ ->
            failwith $"BUG: invalid assignment target: %O{target}"

    | While(cond, body) ->
        /// Condition expression in ANF and related definitions
        let condANF = toANF (toANFDefs cond)
        /// Body of the 'while' loop in ANF
        let bodyANF = toANF (toANFDefs body)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = While(condANF, bodyANF)})

        ({node with Expr = Var(anfDef.Var)}, [anfDef])
    
    | DoWhile(body, cond) -> 
        /// Body of the 'do while' loop in ANF
        let bodyANF = toANF (toANFDefs body)
        /// Condition expression in ANF and related definitions
        let condANF = toANF (toANFDefs cond)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = DoWhile(bodyANF, condANF)})

        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | Type(name, def, scope) ->
        /// Scope expression in ANF
        let scopeANF = toANF (toANFDefs scope)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Type(name, def, scopeANF)})

        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | Lambda(args, body) ->
        // ANF requires variable names to be unique, so we rewrite the body
        /// Variable names bound by the lambda term, and their types
        let argNames, argTypes = List.unzip args
        /// Variable names bound by the lambda term, made unique
        let uniqArgNames = List.map Util.genSymbol argNames
        /// Rewritten lambda term body with renamed variables
        let uniqVarsBody = List.fold (fun body (v, v2) -> substVar body v v2)
                                     body (List.zip argNames uniqArgNames)
        /// Lambda term body in ANF
        let bodyANF = toANF (toANFDefs uniqVarsBody)
        /// Unique lambda term argument names and respective types
        let uniqArgs = List.zip uniqArgNames argTypes

        ({node with Expr = Lambda(uniqArgs, bodyANF)}, [])

    | Application(appExpr, args) ->
        /// Applied expression in ANF and related definitions
        let appExprANF, appExprDefs = toANFDefs appExpr
        /// Application arguments in ANF and related definitions
        let argsANF, argsDefs = List.unzip (List.map toANFDefs args)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Application(appExprANF, argsANF)})

        // Remember: the ANF definitions are ordered with the most recent first
        ({node with Expr = Var(anfDef.Var)},
         anfDef :: List.concat (List.rev argsDefs) @ appExprDefs)

    | StructCons(fields) ->
        let fieldNames, fieldNodes = List.unzip fields
        /// Struct fields in ANF and related definitions
        let fieldsANF, fieldsDefs = List.unzip (List.map toANFDefs fieldNodes)
        /// Updated structure fields (names and nodes) in ANF
        let fields2 = List.zip fieldNames fieldsANF
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = StructCons(fields2)})

        // Remember: the ANF definitions are ordered with the most recent first
        ({node with Expr = Var(anfDef.Var)},
         anfDef :: List.concat (List.rev fieldsDefs))

    | FieldSelect(target, field) ->
        /// Target expression in ANF and related definitions
        let targetANF, targetDefs = toANFDefs target
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = FieldSelect(targetANF, field)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: targetDefs)

    | Pointer _ ->
        failwith "BUG: pointers cannot be converted to ANF (by design!)"

    | UnionCons(label, init) ->
        /// Union initialization expression in ANF and related definitions
        let initANF, initDefs = toANFDefs init
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = UnionCons(label, initANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: initDefs)

    | ArrayCons(length, init) ->
        /// Length expression in ANF and related definitions
        let lengthANF, lengthDefs = toANFDefs length
        /// Init expression in ANF and related definitions
        let initANF, initDefs = toANFDefs init
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = ArrayCons(lengthANF, initANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: (initDefs @ lengthDefs))

    | ArrayElem(target, index) ->
        /// Target expression in ANF and related definitions
        let targetANF, targetDefs = toANFDefs target
        /// Index expression in ANF and related definitions
        /// We need to evaluate the index like an expression because it may be something complex and not simply an int
        let indexANF, indexDefs = toANFDefs index
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = ArrayElem(targetANF, indexANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: (indexDefs @ targetDefs))

    | ArrayLength(target) ->
        /// Target expression in ANF and related definitions
        let targetANF, targetDefs = toANFDefs target
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = ArrayLength(targetANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: targetDefs)

    | ArraySlice(target, startIdx, endIdx) ->
        /// Target expression in ANF and related definitions
        let targetANF, targetDefs = toANFDefs target
        /// startIdx expression in ANF and related definitions
        let startIdxANF, startIdxDefs = toANFDefs startIdx
        /// endIdx expression in ANF and related definitions
        let endIdxANF, endIdxDefs = toANFDefs endIdx
        /// Definition binding this expression in ANF to its variables
        let anfDef = ANFDef(false, {node with Expr = ArraySlice(targetANF, startIdxANF, endIdxANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: (startIdxDefs @ endIdxDefs @ targetDefs))
    
    | Copy arg -> 
        /// Argument in ANF and related definitions
        let argANF, argDefs = toANFDefs arg
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Copy(argANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: argDefs)
    
    | Match(matchExpr, cases) ->
        /// Matched expression in ANF and related definitions
        let matchExprANF, matchExprDefs = toANFDefs matchExpr
        let casesLabels, casesVars, casesConts = List.unzip3 cases
        // ANF requires unique var names, so we rewrite the match continuations
        /// Match case variables, made unique
        let uniqCasesVars = List.map Util.genSymbol casesVars
        /// Rewritten match continuations, using the unique variables
        let uniqCasesConts = List.map (fun (c, v, v2) -> substVar c v v2)
                                      (List.zip3 casesConts casesVars uniqCasesVars)
        /// Match cases continuations in ANF
        let casesContsANF = List.map (fun n -> toANF (toANFDefs n))
                                     uniqCasesConts
        /// Updated match cases with continuations in ANF
        let cases2 = List.zip3 casesLabels uniqCasesVars casesContsANF
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Match(matchExprANF, cases2)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: matchExprDefs)


let internal isReassignedLater (varNameToSearch: string) (remainingDefs: ANFDefs<'E,'T>) : bool =
    List.exists (fun (defEntry: ANFDef<'E, 'T>) ->
        match defEntry.Init.Expr with
        | Assign (targetNode, _valueNode) ->
            match targetNode.Expr with
            | Var tvName when tvName = varNameToSearch -> true // Found a reassignment
            | _ -> false
        | _ -> false
    ) remainingDefs

/// Recursively performs copy propagation on a list of ANF definitions (expected oldest first).
/// Returns the optimized list of definitions and a map of all substitutions performed (eliminated var -> replacement var).
let rec internal doCopyProp
    (defs: ANFDefs<'E, 'T>)
    (substs: Map<string, string>)
    (varMutabilityMap: Map<string, bool>) // Map: varName -> isMutable (true if declared mutable)
    : ANFDefs<'E, 'T> * Map<string, string> =
    match defs with
    | [] -> ([], substs)
    | d :: ds -> 
        // Apply accumulated substitutions to the init part of the current definition 'd'
        let currentInit =
            Map.fold (fun node vOld vNew -> substVar node vOld vNew) d.Init substs
        
        // Create the current definition with potentially substituted init
        let currentDef = ANFDef(d.Var, false, d.IsMutable, currentInit, None)

        match currentDef.Init.Expr with
        | Var(copiedV) ->
            let isCurrentDefVarDeclaredImmutable = not currentDef.IsMutable

            let isCopiedVDeclaredImmutable =
                match Map.tryFind copiedV varMutabilityMap with
                | Some isMutableFlag -> not isMutableFlag
                | None ->
                    printf "Warning: ANF.doCopyProp: Mutability of copied variable '%s' not found in map. Assuming immutable for safety of propagation." copiedV
                    true 

            // Helper to check if variable is redefined (shadowed by let/let mutable) in remaining definitions
            let isShadowedLater (varsToSearch: string list) (remainingDefsLst: ANFDefs<'E, 'T>) =
                List.exists (fun (defEntry: ANFDef<'E, 'T>) -> List.exists (fun (vString: string) -> defEntry.Var = vString) varsToSearch) remainingDefsLst

            // It's safe if it was declared immutable, OR if it was mutable but is not shadowed later.
            let currentDefVarIsSafeToEliminate =
                isCurrentDefVarDeclaredImmutable ||
                ( (not isCurrentDefVarDeclaredImmutable) &&
                  not (isShadowedLater [currentDef.Var] ds) )

            let copiedVIsSafeSource =
                (isCopiedVDeclaredImmutable && not (isShadowedLater [copiedV] ds)) ||
                ( (not isCopiedVDeclaredImmutable) (*i.e., copiedV declared mutable*) &&
                  not (isReassignedLater copiedV ds) &&
                  not (isShadowedLater [copiedV] ds)
                )
            
            let canPropagate = currentDefVarIsSafeToEliminate && copiedVIsSafeSource

            if canPropagate then
                let rec findUltimateSrc v sMap = 
                    match Map.tryFind v sMap with
                    | Some ultimateSrc -> findUltimateSrc ultimateSrc sMap
                    | None -> v
                
                let replacementForDefVar = findUltimateSrc copiedV substs
                let newSubsts = Map.add currentDef.Var replacementForDefVar substs
                
                // Current definition 'currentDef' is removed/skipped. Process rest 'ds' with 'newSubsts'.
                doCopyProp ds newSubsts varMutabilityMap
            else
                // Cannot propagate: Keep currentDef, and process the rest of the list with original 'substs'.
                let optDs, finalSubsts = doCopyProp ds substs varMutabilityMap
                (currentDef :: optDs, finalSubsts)
        | _ ->
            // Not a Var(copiedV) case, so currentDef is not a simple copy. Keep it.
            // Process the rest of the list with original substs.
            let optDs, finalSubsts = doCopyProp ds substs varMutabilityMap
            (currentDef :: optDs, finalSubsts)

/// Transform the given AST node into Administrative Normal Form with copy propagation.
let optTransform (ast: Node<'E, 'T>) : Node<'E, 'T> =
    let node, defs = toANFDefs ast

    let defsOldestFirst = List.rev defs // doCopyProp expects oldest definitions first

    // Build the mutability map: varName -> isMutable (true if 'let mutable')
    let mutabilityMap =
        List.fold (fun accMap (anfDef: ANFDef<'E,'T>) ->
            Map.add anfDef.Var anfDef.IsMutable accMap
        ) Map.empty defsOldestFirst

    // Perform copy propagation
    let optDefsOldestFirst, finalSubsts = doCopyProp defsOldestFirst Map.empty mutabilityMap

    // Apply final substitutions to the resulting node of the program
    let finalNode =
        match node.Expr with
        | Var vname ->
            let rec resolve v sMap = 
                match Map.tryFind v sMap with
                | Some r -> resolve r sMap 
                | None -> v
            let resolvedVname = resolve vname finalSubsts
            { node with Expr = Var resolvedVname }
        | _ -> node 

    let optDefsForToANF = List.rev optDefsOldestFirst // toANF expects most recent definitions first

    toANF (finalNode, optDefsForToANF)
    
/// Helper function to verify the generated ANF from AST is valid:
/// This function does NOT cover all possible ANF translations but verifies at the least all added functionality.
let verifyANF (node: Node<'E,'T>) =
    let mutable isValid = true
    let mutable violations = []

    let rec visit (node: Node<'E,'T>) =
        match node.Expr with
        | Let(var, init, body)
        | LetT(var, _, init, body)
        | LetRec(var, _, init, body)
        | LetMut(var, init, body) ->
            // ANF property check
            let check = 
                match init.Expr with
                | Var _ | IntVal _ | BoolVal _ | FloatVal _ | StringVal _ | UnitVal | Pointer _ -> true
                | ReadInt | ReadFloat -> true
                | Add(a, b)
                | Sub(a, b)
                | Mult(a, b) 
                | And(a, b) 
                | Or(a, b) 
                | Eq(a, b)
                | Less(a, b) 
                | LessEq(a, b) 
                | Greater(a, b) 
                | GreaterEq(a, b)
                | Min(a, b) 
                | Max(a, b) 
                | Div(a, b) 
                | Mod(a, b)  ->
                    match a.Expr, b.Expr with
                    | Var _, Var _ -> true
                    | _ -> false
                | Not(a) 
                | Sqrt(a) 
                | Print(a) 
                | PrintLn(a)
                | Assertion(a) 
                | Ascription(_, a)
                | ArrayLength(a) ->
                    match a.Expr with 
                    | Var _ -> true 
                    | _ -> false
                | ArrayCons(length, init) ->
                    match length.Expr, init.Expr with
                    | Var _, Var _ -> true 
                    | _ -> false
                | ArrayElem(a, idx) ->
                    match a.Expr, idx.Expr with 
                    | Var _, Var _ -> true 
                    | _ -> false
                | ArraySlice(a, s, e) ->
                    match a.Expr, s.Expr, e.Expr with
                    | Var _, Var _, Var _ -> true
                    | _ -> false
                | FieldSelect(a, _) ->
                    match a.Expr with 
                    | Var _ -> true 
                    | _ -> false
                | Application(f, args) ->
                    match f.Expr with
                    | Var _ -> List.forall (fun (arg: Node<'E,'T>) -> 
                        match arg.Expr with 
                        Var _ -> true 
                        | _ -> false) args
                    | _ -> false
                | Copy(a)
                | UnionCons(_, a) ->
                    match a.Expr with 
                    Var _ -> true 
                    | _ -> false

                | Type(_, _, scope) ->
                    // Check that the scope is in ANF
                    visit scope
                    true
                | Lambda (_, body) ->
                    // Check that the body of the lambda is in ANF
                    visit body
                    true
                    
                | If(condition, ifTrue, ifFalse) ->
                    match condition.Expr with
                    | Var _ -> 
                        // We also need to check the other branches for ANF expressions
                        visit ifTrue
                        visit ifFalse
                        true
                    | _ -> false
                
                // For the While loops we recursively visit the body and condition to ensure all expressions within it follow ANF rules.
                | While(condition, body) ->
                    // Check that condition is in ANF
                    visit condition  
                    // Check that body is in ANF
                    visit body
                    true // Not sure if this is correct but we are concerned about checking the cond/body so we jump into those instead
                | DoWhile(body, condition) ->
                    // Check that body is in ANF
                    visit body
                    // Check that condition is in ANF
                    visit condition
                    true

                | StructCons fields ->
                    List.forall (fun (_: string, init: Node<'E, 'T>) ->
                        match init.Expr with
                        | Var _ -> true // All field initializations must be variables
                        | _ -> false
                    ) fields           

                | Assign(target, expr) ->
                    match target.Expr, expr.Expr with
                    | Var _, Var _ -> true  // Simple variable assignment
                    | ArrayElem(a, idx), Var _ ->
                        // Array element assignment
                        match a.Expr, idx.Expr with
                        | Var _, Var _ -> true
                        | _ -> false
                    | FieldSelect(a, _), Var _ ->
                        // Field selection assignment
                        match a.Expr with
                        | Var _ -> true
                        | _ -> false
                    | _ -> false

                | Match(expr, cases) ->
                    // First check that matched expression is a variable
                    match expr.Expr with
                    | Var _ -> 
                        // Then check that all branch continuations are in ANF ignore the strings.
                        let _, _, continuations = List.unzip3 cases
                        List.iter visit continuations
                        true
                    | _ -> false
                    
                | Seq nodes -> 
                    // Check that all nodes in the sequence are in ANF
                    List.map visit nodes |> ignore
                    true
                
                | _ -> false // Other expressions are not allowed in ANF
            
            if not check then
                isValid <- false
                // If we get false we append our failures list to read out later.
                violations <- $"Variable {var} bound to complex expression" :: violations
            
            visit body
            
        | _ -> 
            match node.Expr with
            | Var _ -> () // If the final result is a variable
            | _ -> 
                isValid <- false
                violations <- $"Final expression is not a variable" :: violations
    
    visit node
    
    if isValid then
        printfn "ANF verification complete: Valid ANF"
    else
        printfn "ANF verification failed with %d violations:" violations.Length
        List.iter (printfn "- %s") violations
    

/// Transform the given AST node into Administrative Normal Form.
let transform (ast: Node<'E,'T>): Node<'E,'T> =
    toANF (toANFDefs ast)
