// hyggec - The didactic compiler for the Hygge programming language.
// Copyright (C) 2023 Technical University of Denmark
// Author: Alceste Scalas <alcsc@dtu.dk>
// Released under the MIT license (see LICENSE.md for details)

/// Transformation of a program AST into Administrative Normal Form.
module ANF

open AST


/// ANF definition: a variable name with a boolean mutability boolean flag, and
/// the AST node (expected to be in ANF) that initialises the variable.
type internal ANFDef<'E,'T>(var: string, isMutable: bool, init: Node<'E,'T>) =
    /// Variable introduced by this ANF definition.
    member this.Var = var
    /// Is this ANF definition introducing a mutable variable?
    member this.IsMutable = isMutable
    /// Initialisation expression (in ANF) of this ANF definition.
    member this.Init = init

    /// Construct an ANF definition with an autogenerated unique variable name.
    new(isMutable: bool, init: Node<'E,'T>) =
        ANFDef(Util.genSymbol "$anf", isMutable, init)


/// List of ANF definitions.
type internal ANFDefs<'E,'T> = List<ANFDef<'E,'T>>


/// Utility function to generate a unique variable name for binding ANF
/// definitions.
let internal anfVar() = Util.genSymbol "$anf"


/// Given the AST 'node', return a new AST node where every free occurrence of
/// the variable called 'var' is substituted by variable 'var2'.
let rec substVar (node: Node<'E,'T>) (var: string) (var2: string): Node<'E,'T> =
    match node.Expr with
    | UnitVal
    | IntVal(_)
    | BoolVal(_)
    | FloatVal(_)
    | StringVal(_) -> node // The substitution has no effect

    | Pointer(_) -> node // The substitution has no effect

    | Var(vname) when vname = var -> {node with Expr = Var(var2)} // Substitution applied
    | Var(_) -> node // The substitution has no effect

    | Add(lhs, rhs) ->
        {node with Expr = Add((substVar lhs var var2), (substVar rhs var var2))}
    | Mult(lhs, rhs) ->
        {node with Expr = Mult((substVar lhs var var2), (substVar rhs var var2))}

    | And(lhs, rhs) ->
        {node with Expr = And((substVar lhs var var2), (substVar rhs var var2))}
    | Or(lhs, rhs) ->
        {node with Expr = Or((substVar lhs var var2), (substVar rhs var var2))}
    | Not(arg) ->
        {node with Expr = Not(substVar arg var var2)}

    | Eq(lhs, rhs) ->
        {node with Expr = Eq((substVar lhs var var2), (substVar rhs var var2))}
    | Less(lhs, rhs) ->
        {node with Expr = Less((substVar lhs var var2), (substVar rhs var var2))}

    // New addition
    | LessEq(lhs, rhs) ->
        {node with Expr = LessEq((substVar lhs var var2), (substVar rhs var var2))}

    | Greater(lhs, rhs) ->
        {node with Expr = Greater((substVar lhs var var2), (substVar rhs var var2))}
    
    | GreaterEq(lhs, rhs) ->
        {node with Expr = GreaterEq((substVar lhs var var2), (substVar rhs var var2))}

    | Sqrt(arg) ->
        {node with Expr = Sqrt(substVar arg var var2)}

    | Min(lhs, rhs) -> 
        {node with Expr = Min((substVar lhs var var2), (substVar rhs var var2))}
    
    | Max(lhs, rhs) -> 
        {node with Expr = Max((substVar lhs var var2), (substVar rhs var var2))}

    | Div(lhs, rhs) -> 
         {node with Expr = Div((substVar lhs var var2), (substVar rhs var var2))}

    | Mod(lhs, rhs) -> 
         {node with Expr = Mod((substVar lhs var var2), (substVar rhs var var2))}
    
    | ArrayCons(length, init) ->
         {node with Expr = ArrayCons((substVar length var var2), (substVar init var var2))}

    | ArrayLength(target) ->
         {node with Expr = ArrayLength((substVar target var var2))}

    | ArrayElem(target, index) ->
         {node with Expr = ArrayElem((substVar target var var2), (substVar index var var2))}

    | ArraySlice(target, startIdx, endIdx) ->
         {node with Expr = ArraySlice((substVar target var var2), 
                                    (substVar startIdx var var2),
                                    (substVar endIdx var var2))}
    //   
    | ReadInt
    | ReadFloat -> node // The substitution has no effect

    | Print(arg) ->
        {node with Expr = Print(substVar arg var var2)}
    | PrintLn(arg) ->
        {node with Expr = PrintLn(substVar arg var var2)}

    | If(cond, ifTrue, ifFalse) ->
        {node with Expr = If((substVar cond var var2), (substVar ifTrue var var2),
                                                       (substVar ifFalse var var2))}

    | Seq(nodes) ->
        let substNodes = List.map (fun n -> (substVar n var var2)) nodes
        {node with Expr = Seq(substNodes)}

    | Ascription(tpe, node) ->
        {node with Expr = Ascription(tpe, (substVar node var var2))}

    | Let(vname, init, scope) when vname = var ->
        // Do not substitute the variable in the "let" scope
        {node with Expr = Let(vname,(substVar init var var2), scope)}
    | Let(vname, init, scope) ->
        {node with Expr = Let(vname, (substVar init var var2),
                              (substVar scope var var2))}

    | LetT(vname, tpe, init, scope) when vname = var ->
        // Do not substitute the variable in the "let" scope
        {node with Expr = LetT(vname, tpe, (substVar init var var2), scope)}
    | LetT(vname, tpe, init, scope) ->
        {node with Expr = LetT(vname, tpe, (substVar init var var2),
                               (substVar scope var var2))}

    | LetMut(vname, init, scope) when vname = var ->
        // Do not substitute the variable in the "let mutable" scope
        {node with Expr = LetMut(vname, (substVar init var var2), scope)}
    | LetMut(vname, init, scope) ->
        {node with Expr = LetMut(vname, (substVar init var var2),
                                 (substVar scope var var2))}

    | Assign(target, expr) ->
        {node with Expr = Assign((substVar target var var2), (substVar expr var var2))}
    
    | While(cond, body) ->
        let substCond = substVar cond var var2
        let substBody = substVar body var var2
        {node with Expr = While(substCond, substBody)}

    | DoWhile(body, cond) ->
        let substCond = substVar cond var var2
        let substBody = substVar body var var2
        {node with Expr = DoWhile(substBody, substCond)}

    | Assertion(arg) ->
        {node with Expr = Assertion(substVar arg var var2)}

    | Type(tname, def, scope) ->
        {node with Expr = Type(tname, def, (substVar scope var var2))}

    | Lambda(args, body) ->
        /// Arguments of this lambda term, without their pretypes
        let (argVars, _) = List.unzip args
        if (List.contains var argVars) then node // No substitution
        else {node with Expr = Lambda(args, (substVar body var var2))}

    | Application(expr, args) ->
        let substExpr = substVar expr var var2
        let substArgs = List.map (fun n -> (substVar n var var2)) args
        {node with Expr = Application(substExpr, substArgs)}

    | StructCons(fields) ->
        let (fieldNames, initNodes) = List.unzip fields
        let substInitNodes = List.map (fun e -> (substVar e var var2)) initNodes
        {node with Expr = StructCons(List.zip fieldNames substInitNodes)}

    | FieldSelect(target, field) ->
        {node with Expr = FieldSelect((substVar target var var2), field)}

    | UnionCons(label, expr) ->
        {node with Expr = UnionCons(label, (substVar expr var var2))}

    | Match(expr, cases) ->
        /// Mapper function to propagate the substitution along a match case
        let substCase(lab: string, v: string, cont: Node<'E,'T>) =
            if (v = var) then (lab, v, cont) // Variable bound, no substitution
            else (lab, v, (substVar cont var var2))
        let cases2 = List.map substCase cases
        {node with Expr = Match((substVar expr var var2), cases2)}


/// Convert a given AST node (expected to contain a variable) and a list of ANF
/// definitions (with the most recent at the head of the list) into a
/// corresponding series nested of "let" binders in ANF, having the given AST
/// node in the innermost scope.
let rec internal toANF (node: Node<'E,'T>, defs: ANFDefs<'E,'T>): Node<'E,'T> =
    match defs with
    | [] -> node
    | anfDef :: rest ->
        /// Binder for this ANF definition
        let binder = if anfDef.IsMutable then
                         LetMut(anfDef.Var, anfDef.Init, node)
                     else
                         Let(anfDef.Var, anfDef.Init, node)
        toANF ({node with Expr = binder}, rest)


/// Transform the given AST node into a variable, plus a list of ANF definitions
/// --- i.e. the variable names with their definitions (also in ANF) that are
/// required to compute the returned variable. NOTE: the list of definitions is
/// constructed in reverse, with the most recent addition at the front (to
/// improve performance).
let rec internal toANFDefs (node: Node<'E,'T>): Node<'E,'T> * ANFDefs<'E,'T> =
    match node.Expr with
    | UnitVal
    | BoolVal(_)
    | IntVal(_)
    | FloatVal(_)
    | StringVal(_) as expr ->
        /// Definition binding this value to a variable
        let anfDef = ANFDef(false, {node with Expr = expr})
        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | Var(_) ->
        (node, []) // This AST node is already in ANF

    | Add(lhs, rhs)
    | Mult(lhs, rhs)
    | And(lhs, rhs)
    | Or(lhs, rhs)
    | Eq(lhs, rhs)
    | Less(lhs, rhs)
    | LessEq(lhs, rhs)
    | Greater(lhs, rhs)
    | GreaterEq(lhs, rhs)
    | Min(lhs, rhs)
    | Max(lhs, rhs)
    | Div(lhs, rhs)
    | Mod(lhs, rhs) as expr ->
        /// Left-hand-side argument in ANF and related definitions
        let (lhsANF, lhsDefs) = toANFDefs lhs
        /// Right-hand-side argument in ANF and related definitions
        let (rhsANF, rhsDefs) = toANFDefs rhs
        /// This expression in ANF
        let anfExpr = match expr with
                      | Add(_,_) -> Add(lhsANF, rhsANF)
                      | Mult(_,_) -> Mult(lhsANF, rhsANF)
                      | And(_,_) -> And(lhsANF, rhsANF)
                      | Or(_,_) -> Or(lhsANF, rhsANF)
                      | Eq(_,_) -> Eq(lhsANF, rhsANF)
                      | Less(_,_) -> Less(lhsANF, rhsANF)
                      | LessEq(_,_) -> LessEq(lhsANF, rhsANF)
                      | Greater(_,_) -> Greater(lhsANF, rhsANF)
                      | GreaterEq(_,_) -> GreaterEq(lhsANF, rhsANF)
                      | Min(_,_) -> Min(lhsANF, rhsANF)
                      | Max(_,_) -> Max(lhsANF, rhsANF)
                      | Div(_,_) -> Div(lhsANF, rhsANF)
                      | Mod(_,_) -> Mod(lhsANF, rhsANF)
                      | e -> failwith $"BUG: unexpected expression: %O{e}"
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = anfExpr})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: (rhsDefs @ lhsDefs))

    | ReadInt
    | ReadFloat as expr ->
        /// Definition binding this expression to a variable
        let anfDef = ANFDef(false, {node with Expr = expr})
        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | Not(arg)
    | Print(arg)
    | PrintLn(arg)
    | Assertion(arg)
    | Sqrt(arg) as expr ->
        /// Argument in ANF and related definitions
        let (argANF, argDefs) = toANFDefs arg
        /// This expression in ANF
        let anfExpr = match expr with
                      | Not(_) -> Not(argANF)
                      | Print(_) -> Print(argANF)
                      | PrintLn(_) -> PrintLn(argANF)
                      | Assertion(_)  -> Assertion(argANF)
                      | Sqrt(_) -> Sqrt(argANF)
                      | e -> failwith $"BUG: unexpected expression: %O{e}"
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = anfExpr})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: argDefs)

    | Seq(nodes) ->
        match (List.rev nodes) with
        | [] ->
            failwith $"BUG: empty AST Seq node at %O{node.Pos}"
        | last :: rest ->
            /// Last AST node in the sequence in ANF and related definitions
            let (lastANF, lastDefs) = toANFDefs last
            /// ANF definitions of the rest of the Seq nodes (in reverse order).
            /// We collect the definitions and ignore the variable bound to each
            /// node of the sequence, because such variable will be unused in
            /// the sequence.
            let restANFDefs = List.collect snd (List.map toANFDefs rest)

            (lastANF, lastDefs @ restANFDefs)

    | Ascription(tpe, arg) ->
        /// Argument in ANF and related definitions
        let (argANF, argDefs) = toANFDefs arg
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Ascription(tpe, argANF)})
        ({node with Expr = Var(anfDef.Var)}, anfDef :: argDefs)

    | If(condition, ifTrue, ifFalse) ->
        /// Condition in ANF and related definitions
        let (condANF, condDefs) = toANFDefs condition
        /// True branch in ANF
        let ifTrueANF = toANF (toANFDefs ifTrue)
        /// True branch in ANF
        let ifFalseANF = toANF (toANFDefs ifFalse)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = If(condANF, ifTrueANF, ifFalseANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: condDefs)

    | Let(name, init, scope)
    | LetT(name, _, init, scope)
    | LetMut(name, init, scope) as expr ->
        // ANF requires variable names to be unique, so we rewrite the scope
        /// Variable name bound by this 'let' expression, made unique
        let uniqName = Util.genSymbol name
        /// Rewritten scope with 'name' replaced by 'uniqName'
        let scope = substVar scope name uniqName
        /// Variable name (now made unique) bound by this 'let' expression
        let name = uniqName
        /// Initialization expression in ANF and related definitions
        let (initANF, initDefs) = match init.Expr with
                                  | UnitVal
                                  | BoolVal(_)
                                  | IntVal(_)
                                  | FloatVal(_)
                                  | StringVal(_)
                                  | Var(_) ->
                                      (init, []) // 'init' is already in ANF
                                  | _ ->
                                      toANFDefs init
        /// Scope expression in ANF and its related definitions
        let (scopeANF, scopeDefs)  = toANFDefs scope
        /// Is this a mutable "let"?
        let isMutable = match expr with
                        | Let(_,_,_)
                        | LetT(_,_,_,_) -> false
                        | LetMut(_,_,_) -> true
                        | e -> failwith $"BUG: unexpected expression: %O{e}"
        /// Definition binding the "let" variable to the init expression in ANF
        let letDef = ANFDef(name, isMutable, initANF)

        ({node with Expr = scopeANF.Expr}, scopeDefs @ letDef :: initDefs)

    | Assign(target, asgnExpr) ->
        /// Source expression of the assignment in ANF and related definitions
        let (asgnExprANF, asgnExprDefs) = toANFDefs asgnExpr
        match target.Expr with
        | Var(_) ->
            /// Definition binding this expression in ANF to its variable
            let anfDef = ANFDef(false, {node with Expr = Assign(target, asgnExprANF)})
            ({node with Expr = Var(anfDef.Var)}, anfDef :: asgnExprDefs)
        | FieldSelect(ftarget, field) ->
            /// Target expr of the field selection in ANF and related definitions
            let (ftargetExprANF, ftargetExprDefs) = toANFDefs ftarget
            /// Assignment to field selection in ANF form
            let anfAssign = Assign({target with Expr = FieldSelect(ftargetExprANF, field)}, asgnExprANF)
            /// Definition binding this expression in ANF to its variable
            let anfDef = ANFDef(false, {node with Expr = anfAssign})
            ({node with Expr = Var(anfDef.Var)}, anfDef :: (ftargetExprDefs @ asgnExprDefs))
        | ArrayElem(atarget, index) ->
            /// We also require Assign to handle array elements.
            /// Target array expression in ANF and related definitions
            let (atargetANF, atargetDefs) = toANFDefs atarget
            /// Index expression in ANF and related definitions
            let (indexANF, indexDefs) = toANFDefs index
            /// Assignment to array element in ANF form
            let anfAssign = Assign({target with Expr = ArrayElem(atargetANF, indexANF)}, asgnExprANF)
             /// Definition binding this expression in ANF to its variable
            let anfDef = ANFDef(false, {node with Expr = anfAssign})
            ({node with Expr = Var(anfDef.Var)}, anfDef :: (indexDefs @ atargetDefs @ asgnExprDefs))
        | _ ->
            failwith $"BUG: invalid assignment target: %O{target}"

    | While(cond, body) ->
        /// Condition expression in ANF and related definitions
        let condANF = toANF (toANFDefs cond)
        /// Body of the 'while' loop in ANF
        let bodyANF = toANF (toANFDefs body)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = While(condANF, bodyANF)})

        ({node with Expr = Var(anfDef.Var)}, [anfDef])
    
    | DoWhile(body, cond) -> 
        /// Body of the 'do while' loop in ANF
        let bodyANF = toANF (toANFDefs body)
        /// Condition expression in ANF and related definitions
        let condANF = toANF (toANFDefs cond)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = DoWhile(bodyANF, condANF)})

        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | Type(name, def, scope) ->
        /// Scope expression in ANF
        let scopeANF = toANF (toANFDefs scope)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Type(name, def, scopeANF)})

        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | Lambda(args, body) ->
        // ANF requires variable names to be unique, so we rewrite the body
        /// Variable names bound by the lambda term, and their types
        let (argNames, argTypes) = List.unzip args
        /// Variable names bound by the lambda term, made unique
        let uniqArgNames = List.map Util.genSymbol argNames
        /// Rewritten lambda term body with renamed variables
        let uniqVarsBody = List.fold (fun body (v, v2) -> substVar body v v2)
                                     body (List.zip argNames uniqArgNames)
        /// Lambda term body in ANF
        let bodyANF = toANF (toANFDefs uniqVarsBody)
        /// Unique lambda term argument names and respective types
        let uniqArgs = List.zip uniqArgNames argTypes

        ({node with Expr = Lambda(uniqArgs, bodyANF)}, [])

    | Application(appExpr, args) ->
        /// Applied expression in ANF and related definitions
        let (appExprANF, appExprDefs) = toANFDefs appExpr
        /// Application arguments in ANF and related definitions
        let (argsANF, argsDefs) = List.unzip (List.map toANFDefs args)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Application(appExprANF, argsANF)})

        // Remember: the ANF definitions are ordered with the most recent first
        ({node with Expr = Var(anfDef.Var)},
         anfDef :: List.concat (List.rev argsDefs) @ appExprDefs)

    | StructCons(fields) ->
        let (fieldNames, fieldNodes) = List.unzip fields
        /// Struct fields in ANF and related definitions
        let (fieldsANF, fieldsDefs) = List.unzip (List.map toANFDefs fieldNodes)
        /// Updated structure fields (names and nodes) in ANF
        let fields2 = List.zip fieldNames fieldsANF
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = StructCons(fields2)})

        // Remember: the ANF definitions are ordered with the most recent first
        ({node with Expr = Var(anfDef.Var)},
         anfDef :: List.concat (List.rev fieldsDefs))

    | FieldSelect(target, field) ->
        /// Target expression in ANF and related definitions
        let (targetANF, targetDefs) = toANFDefs target
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = FieldSelect(targetANF, field)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: targetDefs)

    | Pointer(_) ->
        failwith "BUG: pointers cannot be converted to ANF (by design!)"

    | UnionCons(label, init) ->
        /// Union initialization expression in ANF and related definitions
        let (initANF, initDefs) = toANFDefs init
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = UnionCons(label, initANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: initDefs)

    | ArrayCons(length, init) ->
        /// Length expression in ANF and related definitions
        let (lengthANF, lengthDefs) = toANFDefs length
        /// Init expression in ANF and related definitions
        let (initANF, initDefs) = toANFDefs init
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = ArrayCons(lengthANF, initANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: (initDefs @ lengthDefs))

    | ArrayElem(target, index) ->
        /// Target expression in ANF and related definitions
        let (targetANF, targetDefs) = toANFDefs target
        /// Index expression in ANF and related definitions
        /// We need to evaluate the index like an expression because it may be something complex and not simply an int
        let (indexANF, indexDefs) = toANFDefs index
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = ArrayElem(targetANF, indexANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: (indexDefs @ targetDefs))

    | ArrayLength(target) ->
        /// Target expression in ANF and related definitions
        let (targetANF, targetDefs) = toANFDefs target
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = ArrayLength(targetANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: targetDefs)

    | ArraySlice(target, startIdx, endIdx) ->
        /// Target expression in ANF and related definitions
        let (targetANF, targetDefs) = toANFDefs target
        /// startIdx expression in ANF and related definitions
        let (startIdxANF, startIdxDefs) = toANFDefs startIdx
        /// endIdx expression in ANF and related definitions
        let (endIdxANF, endIdxDefs) = toANFDefs endIdx
        /// Definition binding this expression in ANF to its variables
        let anfDef = ANFDef(false, {node with Expr = ArraySlice(targetANF, startIdxANF, endIdxANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: (startIdxDefs @ endIdxDefs @ targetDefs))
    | Match(matchExpr, cases) ->
        /// Matched expression in ANF and related definitions
        let (matchExprANF, matchExprDefs) = toANFDefs matchExpr
        let (casesLabels, casesVars, casesConts) = List.unzip3 cases
        // ANF requires unique var names, so we rewrite the match continuations
        /// Match case variables, made unique
        let uniqCasesVars = List.map Util.genSymbol casesVars
        /// Rewritten match continuations, using the unique variables
        let uniqCasesConts = List.map (fun (c, v, v2) -> substVar c v v2)
                                      (List.zip3 casesConts casesVars uniqCasesVars)
        /// Match cases continuations in ANF
        let casesContsANF = List.map (fun n -> toANF (toANFDefs n))
                                     uniqCasesConts
        /// Updated match cases with continuations in ANF
        let cases2 = List.zip3 casesLabels uniqCasesVars casesContsANF
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Match(matchExprANF, cases2)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: matchExprDefs)

/// Helper function to verify the generated ANF from AST is valid:
/// 
let verifyANF (node: Node<'E,'T>) =
    let mutable isValid = true
    let mutable violations = []

    let rec visit (node: Node<'E,'T>) =
        match node.Expr with
        | Let(var, init, body)
        | LetMut(var, init, body) ->
            // ANF property check
            let isSimpleInit = 
                match init.Expr with
                | Var(_) | IntVal(_) | BoolVal(_) | FloatVal(_) | StringVal(_) | UnitVal -> true
                | Add(a, b) 
                | Mult(a, b) 
                | And(a, b) 
                | Or(a, b) 
                | Eq(a, b)
                | Less(a, b) 
                | LessEq(a, b) 
                | Greater(a, b) 
                | GreaterEq(a, b)
                | Min(a, b) 
                | Max(a, b) 
                | Div(a, b) 
                | Mod(a, b) 
                | Eq(a, b) ->
                    match a.Expr, b.Expr with
                    | Var(_), Var(_) -> true
                    | _ -> false
                | Not(a) 
                | Print(a) 
                | PrintLn(a) 
                | Assertion(a) 
                | Sqrt(a) 
                | ArrayLength(a) ->
                    match a.Expr with Var(_) -> true | _ -> false
                | ArrayCons(length, init) ->
                    match length.Expr, init.Expr with
                    | Var(_), Var(_) -> true 
                    | _ -> false
                | ArrayElem(a, idx) ->
                    match a.Expr, idx.Expr with 
                    | Var(_), Var(_) -> true 
                    | _ -> false
                | ArraySlice(a, s, e) ->
                    match a.Expr, s.Expr, e.Expr with
                    | Var(_), Var(_), Var(_) -> true
                    | _ -> false
                | FieldSelect(a, fieldName) ->
                    match a.Expr with 
                    | Var(_) -> true 
                    | _ -> false
                | Application(f, args) ->
                    match f.Expr with
                    | Var(_) -> List.forall (fun (arg: Node<'E,'T>) -> match arg.Expr with Var(_) -> true | _ -> false) args
                    | _ -> false
                | UnionCons(_, a) ->
                    match a.Expr with Var(_) -> true | _ -> false
                | If(condition, ifTrue, ifFalse) ->
                    match condition.Expr with
                    | Var(_) -> 
                        // We also need to check the other branches for ANF expressions
                        visit ifTrue
                        visit ifFalse
                        true
                    | _ -> false
                | While(condition, body) ->
                    // Check that condition is in ANF
                    visit condition  
                    // Check that body is in ANF
                    visit body
                    true // Not sure if this is correct but we are concerned about checking the cond/body so we jump into those instead
                | DoWhile(body, condition) ->
                    // Check that body is in ANF
                    visit body
                    // Check that condition is in ANF
                    visit condition
                    true
                | Assign(target, expr) ->
                    match target.Expr, expr.Expr with
                    | Var(_), Var(_) -> true  // Simple variable assignment
                    | ArrayElem(a, idx), Var(_) ->
                        // Array element assignment
                        match a.Expr, idx.Expr with
                        | Var(_), Var(_) -> true
                        | _ -> false
                    | FieldSelect(a, _), Var(_) ->
                        // Field selection assignment
                        match a.Expr with
                        | Var(_) -> true
                        | _ -> false
                    | _ -> false
                | Match(expr, cases) ->
                    // First check that matched expression is a variable
                    match expr.Expr with
                    | Var(_) -> 
                        // Then check that all branch continuations are in ANF ingnore the strings.
                        let (_, _, continuations) = List.unzip3 cases
                        List.iter visit continuations
                        true
                    | _ -> false
                | _ -> false
            
            if not isSimpleInit then
                isValid <- false
                // If we get false we append our failures list to read out later.
                violations <- $"Variable {var} bound to complex expression" :: violations
            
            visit body
            
        | _ -> 
            match node.Expr with
            | Var(_) -> () // If the final result is a variable
            | _ -> 
                isValid <- false
                violations <- $"Final expression is not a variable" :: violations
    
    visit node
    
    if isValid then
        printfn "ANF verification complete: Valid ANF"
    else
        printfn "ANF verification failed with %d violations:" violations.Length
        List.iter (printfn "- %s") violations
    

/// Transform the given AST node into Administrative Normal Form.
let transform (ast: Node<'E,'T>): Node<'E,'T> =
    toANF (toANFDefs ast)


