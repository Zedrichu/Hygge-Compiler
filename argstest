.data:
string_val:
    .string "***********************"
string_val_1:
    .string "Assertion error @ .\tests\codegen\pass\025-more-than-8-args-float.hyg:10:1"
string_val_2:
    .string "-----------------------"
string_val_3:
    .string " 10: assert(result_add = 11.0f)"
string_val_4:
    .string "...: ^"
string_val_5:
    .string "***********************"

.text:
    mv fp, sp  # Initialize frame pointer
    addi sp, sp, -4  # Allocate stack space to save register
    sw t0, 0(sp)  # Save env.Target register to stack
    li t0, 1186300416  # Float value 23233.000000
    fmv.w.x ft0, t0  # Move float value 23233.000000 to FP register
    lw t0, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    la t0, fun_addFirstAndLast  # Load plain fun_addFirstAndLast function address
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a0, 4  # Amount of memory to allocate for a struct (in bytes)
    li a7, 9  # RARS syscall: Sbrk
    ecall
    mv t1, a0  # Move syscall result (struct mem address) to target
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    mv t2, t0  # Load variable '~v''
    sw t2, 0(t1)  # Initialize struct field '~f'
    mv t0, t1  # Move closure result to target register
    # Load expression to be applied as a function
    mv t1, t0  # Load variable 'addFirstAndLast'
    lw t1, 0(t1)  # Load plain function address `~f` from closure
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1065353216  # Float value 1.000000
    fmv.w.x ft1, t1  # Move float value 1.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1073741824  # Float value 2.000000
    fmv.w.x ft2, t1  # Move float value 2.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1077936128  # Float value 3.000000
    fmv.w.x ft3, t1  # Move float value 3.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1082130432  # Float value 4.000000
    fmv.w.x ft4, t1  # Move float value 4.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1084227584  # Float value 5.000000
    fmv.w.x ft5, t1  # Move float value 5.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1086324736  # Float value 6.000000
    fmv.w.x ft6, t1  # Move float value 6.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1088421888  # Float value 7.000000
    fmv.w.x ft7, t1  # Move float value 7.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1090519040  # Float value 8.000000
    fmv.w.x fs0, t1  # Move float value 8.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1091567616  # Float value 9.000000
    fmv.w.x fs1, t1  # Move float value 9.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1092616192  # Float value 10.000000
    fmv.w.x fs2, t1  # Move float value 10.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    mv t2, t0  # Load variable 'addFirstAndLast'
    # Before function call: save caller-saved registers
    addi sp, sp, -136  # Update stack pointer to make room for saved registers
    sw ra, 0(sp)
    sw a0, 4(sp)
    sw a1, 8(sp)
    sw a2, 12(sp)
    sw a3, 16(sp)
    sw a4, 20(sp)
    sw a5, 24(sp)
    sw a6, 28(sp)
    sw a7, 32(sp)
    sw t0, 36(sp)
    sw t2, 40(sp)
    sw t3, 44(sp)
    sw t4, 48(sp)
    sw t5, 52(sp)
    sw t6, 56(sp)
    fsw fa0, 60(sp)
    fsw fa1, 64(sp)
    fsw fa2, 68(sp)
    fsw fa3, 72(sp)
    fsw fa4, 76(sp)
    fsw fa5, 80(sp)
    fsw fa6, 84(sp)
    fsw fa7, 88(sp)
    fsw ft0, 92(sp)
    fsw ft2, 96(sp)
    fsw ft3, 100(sp)
    fsw ft4, 104(sp)
    fsw ft5, 108(sp)
    fsw ft6, 112(sp)
    fsw ft7, 116(sp)
    fsw ft8, 120(sp)
    fsw ft9, 124(sp)
    fsw ft10, 128(sp)
    fsw ft11, 132(sp)
    addi sp, sp, -8  # Update stack pointer for the overflowing args with overflow of 2 units
    fmv.s fa0, ft1  # Load float function call argument 1 from FP register 'ft1' to target FP register 'fa0'
    fmv.s fa1, ft2  # Load float function call argument 2 from FP register 'ft2' to target FP register 'fa1'
    fmv.s fa2, ft3  # Load float function call argument 3 from FP register 'ft3' to target FP register 'fa2'
    fmv.s fa3, ft4  # Load float function call argument 4 from FP register 'ft4' to target FP register 'fa3'
    fmv.s fa4, ft5  # Load float function call argument 5 from FP register 'ft5' to target FP register 'fa4'
    fmv.s fa5, ft6  # Load float function call argument 6 from FP register 'ft6' to target FP register 'fa5'
    fmv.s fa6, ft7  # Load float function call argument 7 from FP register 'ft7' to target FP register 'fa6'
    fmv.s fa7, fs0  # Load float function call argument 8 from FP register 'fs0' to target FP register 'fa7'
    fsw fs1, 0(sp)  # Store float function call argument 9 to stack at offset 0
    fsw fs2, 4(sp)  # Store float function call argument 10 to stack at offset 4
    mv a0, t2  # Load function call argument 1
    jalr ra, 0(t1)  # Function call
    # After function call
    fmv.s ft1, fa0  # Copy function return value to target floating point register
    addi sp, sp, 8  # Restore SP by 2 function args after function call
    # Restore caller-saved registers
    lw ra, 0(sp)
    lw a0, 4(sp)
    lw a1, 8(sp)
    lw a2, 12(sp)
    lw a3, 16(sp)
    lw a4, 20(sp)
    lw a5, 24(sp)
    lw a6, 28(sp)
    lw a7, 32(sp)
    lw t0, 36(sp)
    lw t2, 40(sp)
    lw t3, 44(sp)
    lw t4, 48(sp)
    lw t5, 52(sp)
    lw t6, 56(sp)
    flw fa0, 60(sp)
    flw fa1, 64(sp)
    flw fa2, 68(sp)
    flw fa3, 72(sp)
    flw fa4, 76(sp)
    flw fa5, 80(sp)
    flw fa6, 84(sp)
    flw fa7, 88(sp)
    flw ft0, 92(sp)
    flw ft2, 96(sp)
    flw ft3, 100(sp)
    flw ft4, 104(sp)
    flw ft5, 108(sp)
    flw ft6, 112(sp)
    flw ft7, 116(sp)
    flw ft8, 120(sp)
    flw ft9, 124(sp)
    flw ft10, 128(sp)
    flw ft11, 132(sp)
    addi sp, sp, 136  # Restore stack pointer after register restoration
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1065353216  # Float value 1.000000
    fmv.w.x ft2, t1  # Move float value 1.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1073741824  # Float value 2.000000
    fmv.w.x ft3, t1  # Move float value 2.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    fadd.s ft2, ft2, ft3
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1082130432  # Float value 4.000000
    fmv.w.x ft3, t1  # Move float value 4.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    fadd.s ft2, ft2, ft3
    fmv.s ft3, ft1  # Load variable 'result_add'
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    fsw fa0, 4(sp)
    fmv.s fa0, ft3  # Copy to fa0 for printing
    li a7, 2  # RARS syscall: PrintFloat
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    flw fa0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    fmv.s ft3, ft0  # Load variable 'p'
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    fsw fa0, 4(sp)
    fmv.s fa0, ft3  # Copy to fa0 for printing
    li a7, 2  # RARS syscall: PrintFloat
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    flw fa0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    fmv.s ft3, ft1  # Load variable 'result_add'
    addi sp, sp, -4  # Allocate stack space to save register
    sw t1, 0(sp)  # Save env.Target register to stack
    li t1, 1093664768  # Float value 11.000000
    fmv.w.x ft4, t1  # Move float value 11.000000 to FP register
    lw t1, 0(sp)  # Restore env.Target register from stack
    addi sp, sp, 4  # Deallocate stack space
    feq.s t1, ft3, ft4
    bnez t1, if_true  # Jump when 'if' condition is true
    la t1, if_false  # Load the address of the 'false' branch of the 'if' code
    jr t1  # Jump to the 'false' branch of the 'if' code
if_true:  # Beginning of the 'true' branch of the 'if' code
    la t2, if_end  # Load the address of the end of the 'if' code
    jr t2  # Jump to skip the 'false' branch of 'if' code
if_false:  # Beginning of the 'false' branch of the 'if' code
    la t1, string_val
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_1
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_2
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_3
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_4
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_5
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    li t1, 0  # Bool value 'False'
    addi t1, t1, -1
    beqz t1, assert_true  # Jump if assertion OK
    li a7, 93  # RARS syscall: Exit2
    li a0, 42  # Assertion violation exit code
    ecall
assert_true:
if_end:  # End of the 'if' code
    fmv.s ft2, ft3  # Move result of 'let' scope expression into target register
    fmv.s ft1, ft2  # Move result of 'let' scope expression into target register
    fmv.s ft0, ft1  # Move result of 'let' scope expression into target register
    li a7, 10  # RARS syscall: Exit
    ecall  # Successful exit with code 0


fun_addFirstAndLast:  # Plain lambda term (fun instance) or named function code
    # Function prologue begins here
    # Save callee-saved registers
    addi sp, sp, -48  # Update stack pointer to make room for saved registers
    sw fp, 0(sp)
    sw s1, 4(sp)
    sw s2, 8(sp)
    sw s3, 12(sp)
    sw s4, 16(sp)
    sw s5, 20(sp)
    sw s6, 24(sp)
    sw s7, 28(sp)
    sw s8, 32(sp)
    sw s9, 36(sp)
    sw s10, 40(sp)
    sw s11, 44(sp)
    addi fp, sp, 48  # Update frame pointer for the current function
    # End of function prologue.  Function body begins
    fmv.s ft0, fa0  # Load variable 'x1'
    flw ft1, 4(fp)  # Load float variable 'x10' from stack at offset 4
    fadd.s ft0, ft0, ft1
    # End of function body.  Function epilogue begins
    fmv.s fa0, ft0  # Move float result of function into return value register
    # Restore callee-saved registers
    lw fp, 0(sp)
    lw s1, 4(sp)
    lw s2, 8(sp)
    lw s3, 12(sp)
    lw s4, 16(sp)
    lw s5, 20(sp)
    lw s6, 24(sp)
    lw s7, 28(sp)
    lw s8, 32(sp)
    lw s9, 36(sp)
    lw s10, 40(sp)
    lw s11, 44(sp)
    flw fs0, 48(sp)
    flw fs1, 52(sp)
    flw fs2, 56(sp)
    flw fs3, 60(sp)
    flw fs4, 64(sp)
    flw fs5, 68(sp)
    flw fs6, 72(sp)
    flw fs7, 76(sp)
    flw fs8, 80(sp)
    flw fs9, 84(sp)
    flw fs10, 88(sp)
    flw fs11, 92(sp)
    addi sp, sp, 96  # Restore stack pointer after register restoration
    jr ra  # End of function, return to caller
