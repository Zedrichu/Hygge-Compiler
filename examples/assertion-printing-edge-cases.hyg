//==============================================================================
// SECTION 6: EDGE CASES AND LIMITATIONS
//==============================================================================

// Test 6.1: Functions with side effects - demonstrates why function calls
// can't be safely evaluated in assertion reporting
fun test6_1(): unit = {
    let mutable counter = 0;
    
    fun incrementCounter(): int = {
        counter <- counter + 1;
        counter
    };
    
    assert(incrementCounter() = incrementCounter())  // Will always fail, reports counter
    // If we fully evaluated the functions during error reporting, counter would be
    // incremented twice more, showing a different value than what caused the failure
};

// Test 6.3: Expressions with exceptions - would crash if evaluated
fun test6_2(): unit = {
    let a = 0;
    
    assert(5 / a > 0)  // Reports a = 0, but doesn't try to evaluate 5/0
    // Directly evaluating would cause a division by zero error
};

// Test 6.4: Array access with out of bounds - would crash if evaluated
fun test6_3(): unit = {
    let arr = array(3, 0);
    let idx = 5;  // Out of bounds
    
    assert(arrayElem(arr, idx) = 0)  // Reports arr and idx, doesn't try to access arr[5]
    // Directly evaluating would cause an out of bounds error
};

// Test 6.5: Variable going out of scope during evaluation
fun test6_4(): unit = {
    assert(arrayElem({
        let temp = array(5, 10);  // temp goes out of scope immediately
        temp  // But we still need its value for the assertion
    }, 0) = 5)
    // This demonstrates why we can't safely capture all variables that
    // might be relevant to the assertion
};

// Test 6.6: Nested assertions with complex expressions
fun test6_5(): unit = {
    let mutable x = 0;
    
    assert({
        assert({
            let y = 5;
            x = y  // Inner assertion fails stopping execution
        });
        x = 0
    })
};

// Test 6.7: Multiple mutable updates in sequence
fun test6_6(): unit = {
    let mutable count = 0;
    
    fun complexOperation(): bool = {
        count <- count + 1;
        if (count > 4) then
            true
        else 
            false
    };
    
    assert({complexOperation(); complexOperation(); complexOperation(); complexOperation()})
    // Shows variable values at the exact point of failure
};

// During time of development - only available for interpreter
// Test 6.8: Unions and pattern matching
// fun test6_7(): unit = {
//     type Optional = union {
//         Some: int;
//         None: unit
//     };
    
//     let value = None{()};
    
//     assert(match value with {
//         Some{x} -> x > 0;
//         None{_} -> false  // This branch is taken, causing failure
//     })
//     // Reports the union value, but doesn't try to evaluate the match
// };

//==============================================================================
// MAIN TEST RUNNER - Uncomment only one test at a time
//==============================================================================

// Edge cases
// test6_1();  // Functions with side effects
// test6_2();  // Division by zero
// test6_3();  // Array out of bounds
// test6_4();  // Variable scope issues
// test6_5();  // Nested assertions
test6_6();  // Multiple state updates
// test6_7();  // Unions and pattern matching

()