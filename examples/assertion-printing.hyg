//==============================================================================
// HYGGE LANGUAGE ASSERTION TESTING EXAMPLES
//
// This file contains various examples to demonstrate the assertion error
// reporting capabilities of the Hygge compiler. Each section is independent
// and can be tested by uncommenting it while commenting out other sections.
//==============================================================================

//==============================================================================
// SECTION 1: BASIC ASSERTIONS WITH MUTABLE VARIABLES
//==============================================================================
let mutable x = 0;

fun incX(): int = x <- x + 1;
assert({incX(); incX(); x = 3})

// Example with nested assertions
// assert({assert(x=1); assert({assert(false); x = 2}); x = 1})

// Example with nested let bindings and assertions
// assert(
//     {
//         let y = {assert(x = 0);5};
//         // let y = 1;
//         assert(x=0); 
//         assert(
//             {
//                 assert(true); 
//                 x = 0
//             });
//         let y = 2;
//         x + y = 1
//     }
// )

// Conditional assertion example
// let y = 1;
// let z = 3;
// assert(if x = 0 then y = 2 else z = 4)

//==============================================================================
// SECTION 2: NESTED ASSERTIONS WITH MUTABLE STATE
//==============================================================================
// let mutable y = 0;
// assert({{let x = 1; let mutable y = 2; x=y};{ y <- 3; {assert(y = 0); assert(true); y = -1}}})

//==============================================================================
// SECTION 3: STRUCT ASSERTIONS
//==============================================================================
// type Shape = struct { name: string;
//                       area: int;
//                       perimeter: int };

// let c: Shape = struct { name = "Circle";
//                          area = 1;
//                          perimeter = 2 };

// fun getStruct(): Shape = c;

// // Struct field comparison assertion
// assert({let c: Shape = struct { name = "Circle";
//                          area = 1;
//                          perimeter = 2 }; c.perimeter = c.area })

// // Function application with structs
// assert({{c.perimeter = 2; false}; false})
// assert((getStruct()).perimeter = (getStruct()).area)

//==============================================================================
// SECTION 4: FUNCTION APPLICATION ASSERTIONS
//==============================================================================
// let v = 5;
// rec fun myFunc(x: int) : int = {
//     if x = 0 then 0
//     else if x = 1 then 1
//     else myFunc(x - 1) + myFunc(x - 2)
// };
// assert(6 = myFunc(myFunc(myFunc(myFunc(v)))))

//==============================================================================
// SECTION 5: ARRAY ASSERTIONS
//==============================================================================
// type myArr = array {int};
// fun getArr(): myArr = array(10, 40 + 2);
// let arr: myArr = array(10, 3);
// let i = 0;
// assert(arrayLength({false; getArr()}) = 5)

//==============================================================================
// SECTION 6: FUNCTIONS IN STRUCTS
//==============================================================================
// type funStruct = struct {
//     f: (int) -> int;
//     g: (int) -> int
// };
// let bifun: funStruct = struct {
//     f = fun(x: int) -> x + 1;
//     g = fun(x: int) -> x + 2
// };
// assert(bifun.f(bifun.g(bifun.f(bifun.g(5)))) = 0)
// assert(bifun.f(5) = 0)

//==============================================================================
// SECTION 7: NESTED FUNCTION APPLICATIONS WITH SIDE EFFECTS
//==============================================================================
// let mutable v = 5;
// fun f(x: int): int = v <- v + 1;
// assert(f(f(f(f(v)))) = 7)

//==============================================================================
// SECTION 8: HIGHER-ORDER FUNCTIONS
//==============================================================================
// fun makeFun(): () -> int =
// {
//     fun inc(): int = 1;
//     inc
// };
// assert((makeFun())() = 43)

//==============================================================================
// SECTION 9: COMPLEX EXPRESSIONS WITH ARRAYS AND STRUCTS
//==============================================================================
// type OthrStruct = struct { o: int };
// type IdxStruct = struct { idx: int; s: OthrStruct };
// fun getIdx(): int = 0;
// fun getIdx(dummy: (int) -> unit): int = 0;

// let mutable x = 0;
// let y = 1;

// fun getArr(dummy: int): array {int} = { x <- x + 1; array(10, 40 + 2) };
// fun d(a: int): unit = ();

// let idx: IdxStruct = struct { idx = 0; s = struct { o = 1 } };
// let arr: array {int} = array(10, 40 + 2);
// assert(arrayElem(arr, getIdx(d)) = x)
// assert(arrayLength(arr) = x)
// assert(arrayLength(slice(arr, x, 2)) = x)

//==============================================================================
// SECTION 10: ARRAY SCOPING EXAMPLES
//==============================================================================
// fun getArr(): array {int} = { array(10, 40 + 2) };
// fun f(x: int, y: array {int}): int = arrayElem(y, x);
// let arr: array {int} = array(10, 42);
// assert(arrayElem({let x = array(5, 10); x}, 0) = 0) // x is not reported as it falls out of scope during argument evaluation

//==============================================================================
// SECTION 11: UNION TYPES AND PATTERN MATCHING
//==============================================================================
// type OptionalInt = union {
//     Some: int;
//     None: unit
// };

// type NestedOptionalInt = union {
//     Some: OptionalInt;
//     None: unit
// };

// fun displayOption(o: NestedOptionalInt): unit =
//     match o with {
//         Some{x} -> 
//             match x with {
//                 Some{y} -> println(y);
//                 None{_} -> println("None")
//             }
//             // println(x);
//         None{_} -> println("None")
//     };

// fun getOption(o: NestedOptionalInt): int =
//     match o with {
//         Some{x} ->
//             match x with {
//                 Some{y} -> y;
//                 None{_} -> -2
//             };
//         None{_} -> -1
//     };
// let a = 42;
// assert(getOption(Some{Some{a}}) = 0)
// displayOption(Some{42});
// displayOption(None{()});

//==============================================================================
// SECTION 12: SHAPE UNION TYPE WITH AREA CALCULATION
//==============================================================================
// // A shape type.
// type Shape = union {
//     Circle: struct { radius: float };
//     Rectangle: struct { width: float; height: float };
//     Square: struct { side: float }
// };

// // Return the area of a shape.
// fun area(s: Shape): float =
//     match s with {
//         Circle{c} -> c.radius * c.radius * 3.14f;
//         Rectangle{r} -> r.width * r.height;
//         Square{s} -> s.side * s.side
//     };

// assert(area(Circle{struct {radius = 2.0f}}) = 0.0f);
// assert(area(Rectangle{struct {width = 2.0f; height = 3.0f}}) = 6.0f);
// assert(area(Square{struct {side = 5.0f}}) = 25.0f)

//==============================================================================
// SECTION 13: SCOPE TESTING WITH ASSERTIONS
//==============================================================================
// let x = 0;
// assert({let y = 1; x - y = 0})

//==============================================================================
// SECTION 14: DO-WHILE LOOP WITH NESTED ASSERTIONS
//==============================================================================
// let mutable x = 0;
// let y: int = do {
//    x <- x + 1
//    // {assert({x; assert(false); true}); x < 5}
// } while ({assert({x; let z = 5; assert({z; let a = z / 5; x = 10 || a = 2}); true}); x < 5});
// ()

//==============================================================================
// SECTION 15: FUNCTION TYPE ASSERTIONS
//==============================================================================
// type myFunType = (int) -> unit;
// let myFun: myFunType = fun(x: int) -> { x; () };
// fun wrapper(f: myFunType): bool = false;
// assert(wrapper(myFun))