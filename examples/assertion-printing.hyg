//==============================================================================
// HYGGE LANGUAGE ASSERTION TESTING EXAMPLES
//
// This file demonstrates how variables are reported when assertions fail.
// The compiler identifies and reports only variables that are directly
// referenced in the key assertion expression (the final condition).
//==============================================================================

//==============================================================================
// SECTION 1: BASIC VARIABLE REPORTING IN ASSERTIONS
//==============================================================================

// Test 1.1: Simple variable reporting - only x and y are reported
fun test1_1(): unit = {
    let x = 10;
    let y = 20;
    let unused = 30;  // This variable won't appear in the report
    assert(x > y)  // Reports x = 10, y = 20 (but not unused)
};

// Test 1.2: Only variables used in the final condition are reported
fun test1_2(): unit = {
    let a = 5;
    let b = 10;
    let c = 15;
    
    assert({
        let temp = a + b;  // Intermediate calculation
        c < temp  // Only c and temp are reported, not a or b directly
    })
};

//==============================================================================
// SECTION 2: NESTED SCOPES AND VARIABLE CAPTURE
//==============================================================================

// Test 2.1: Variables from outer scopes are reported when used
fun test2_1(): unit = {
    let outer = 100;
    
    assert({
        let inner = 50;
        outer < inner  // Both outer and inner are reported
    })
};

// Test 2.2: Only the variables in the final condition are reported
fun test2_2(): unit = {
    let x = 1;
    let y = 2;
    
    assert({
        let z = 3;
        {
            let w = 4;
            z > w  // Only z and w are reported, not x or y
        }
    })
};

//==============================================================================
// SECTION 3: MUTABLE VARIABLES AND STATE CHANGES
//==============================================================================

// Test 3.1: Current value of mutable variables is reported
fun test3_1(): unit = {
    let mutable counter = 0;
    
    for (let mutable i = 0; i < 5; i <- i + 1) {
        counter <- counter + i
    };
    
    assert(counter < 10)  // Reports current value of counter (10)
};

// Test 3.2: Complex expressions with mutated state
let mutable x = 0;
fun test3_2(): unit = {
    let original = x;
    
    fun incX(): int = {println(x); x <- x + 1};

    assert({
        incX();
        incX();
        // Only reports x and original, not the function itself
        x = original  // Reports x = 2, original = 0
    })
};

//==============================================================================
// SECTION 4: COMPOUND DATA STRUCTURES
//==============================================================================

// Test 4.1: Struct fields in assertions
fun test4_1(): unit = {
    type Person = struct { 
        name: string;
        age: int
    };
    
    let p = struct { 
        name = "Alice"; 
        age = 30
    };
    
    let threshold = 25;
    
    assert(p.age < threshold)   // Reports p = struct { name = "Alice"; age = 30; }, threshold = 25
};

// Test 4.2: Array elements in assertions
fun test4_2(): unit = {
    let arr = array(3, 0);
    arrayElem(arr, 0) <- 10;
    arrayElem(arr, 1) <- 20;
    arrayElem(arr, 2) <- 30;
    
    let idx = 1;
    let value = 15;
    
    assert(arrayElem(arr, idx) < value) // Reports arr = Array{ type: int; length: 3 }, 
                                        // idx = 1, value = 15
};

//==============================================================================
// SECTION 5: FUNCTION CALLS AND EXPRESSIONS
//==============================================================================

// Test 5.1: Function results in assertions
fun test5_1(): unit = {
    let base_val = 10;
    
    fun double(n: int): int = n * 2;
    fun triple(n: int): int = n * 3;
    
    assert(double(base_val) > triple(base_val))  // Reports base_val = 10 and relevant functions
};

// Test 5.2: Logical combinations with short-circuiting
fun test5_2(): unit = {
    let a = true;
    let b = false;
    let c = false;
    let d = true;
    
    assert((a && b) || (c && d))  // Reports a = true, b = false, c = false, d = true
};


//==============================================================================
// MAIN TEST RUNNER - Uncomment only one test at a time
//==============================================================================

// Basic tests
test1_1();  // Basic variable reporting
// test1_2();  // Variables in final condition
// test2_1();  // Outer scope variables
// test2_2();  // Nested scope variables
// test3_1();  // Mutable variable current state
// test3_2();  // Mutation and state changes
// test4_1();  // Struct field access
// test4_2();  // Array element access
// test5_1();  // Function application results
// test5_2();  // Logical combinations

()