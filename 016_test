.data:
string_val:
    .string "***********************"
string_val_6:
    .string "Assertion error @ .\tests\codegen\pass\016-fun.hyg:8:1"
string_val_7:
    .string "-----------------------"
string_val_8:
    .string "  8: assert(h(1) = 42);"
string_val_9:
    .string "...: ^"
string_val_10:
    .string "***********************"
string_val_18:
    .string "***********************"
string_val_19:
    .string "Assertion error @ .\tests\codegen\pass\016-fun.hyg:9:1"
string_val_20:
    .string "-----------------------"
string_val_21:
    .string "  9: assert(h(42) = 1)"
string_val_22:
    .string "...: ^"
string_val_23:
    .string "***********************"

.text:
    mv fp, sp  # Initialize frame pointer
    # Load expression to be applied as a function
    la t0, fun_h  # Load variable 'h' (labmda term)
    li t1, 42
    # Before function call: save caller-saved registers
    addi sp, sp, -60  # Update stack pointer to make room for saved registers
    sw ra, 0(sp)
    sw a0, 4(sp)
    sw a1, 8(sp)
    sw a2, 12(sp)
    sw a3, 16(sp)
    sw a4, 20(sp)
    sw a5, 24(sp)
    sw a6, 28(sp)
    sw a7, 32(sp)
    sw t1, 36(sp)
    sw t2, 40(sp)
    sw t3, 44(sp)
    sw t4, 48(sp)
    sw t5, 52(sp)
    sw t6, 56(sp)
    mv a0, t1  # Load function call argument 1
    jalr ra, 0(t0)  # Function call
    # After function call
    mv t0, a0  # Copy function return value to target register
    # Restore caller-saved registers
    lw ra, 0(sp)
    lw a0, 4(sp)
    lw a1, 8(sp)
    lw a2, 12(sp)
    lw a3, 16(sp)
    lw a4, 20(sp)
    lw a5, 24(sp)
    lw a6, 28(sp)
    lw a7, 32(sp)
    lw t1, 36(sp)
    lw t2, 40(sp)
    lw t3, 44(sp)
    lw t4, 48(sp)
    lw t5, 52(sp)
    lw t6, 56(sp)
    addi sp, sp, 60  # Restore stack pointer after register restoration
    mv t1, t0  # Load variable 'result'
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 1  # RARS syscall: PrintInt
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Load expression to be applied as a function
    la t1, fun_h  # Load variable 'h' (labmda term)
    li t2, 1
    # Before function call: save caller-saved registers
    addi sp, sp, -60  # Update stack pointer to make room for saved registers
    sw ra, 0(sp)
    sw a0, 4(sp)
    sw a1, 8(sp)
    sw a2, 12(sp)
    sw a3, 16(sp)
    sw a4, 20(sp)
    sw a5, 24(sp)
    sw a6, 28(sp)
    sw a7, 32(sp)
    sw t0, 36(sp)
    sw t2, 40(sp)
    sw t3, 44(sp)
    sw t4, 48(sp)
    sw t5, 52(sp)
    sw t6, 56(sp)
    mv a0, t2  # Load function call argument 1
    jalr ra, 0(t1)  # Function call
    # After function call
    mv t1, a0  # Copy function return value to target register
    # Restore caller-saved registers
    lw ra, 0(sp)
    lw a0, 4(sp)
    lw a1, 8(sp)
    lw a2, 12(sp)
    lw a3, 16(sp)
    lw a4, 20(sp)
    lw a5, 24(sp)
    lw a6, 28(sp)
    lw a7, 32(sp)
    lw t0, 36(sp)
    lw t2, 40(sp)
    lw t3, 44(sp)
    lw t4, 48(sp)
    lw t5, 52(sp)
    lw t6, 56(sp)
    addi sp, sp, 60  # Restore stack pointer after register restoration
    li t2, 42
    beq t1, t2, eq_true
    li t1, 0  # Comparison result is false
    j eq_end
eq_true:
    li t1, 1  # Comparison result is true
eq_end:
    bnez t1, if_true_3  # Jump when 'if' condition is true
    la t1, if_false_4  # Load the address of the 'false' branch of the 'if' code
    jr t1  # Jump to the 'false' branch of the 'if' code
if_true_3:  # Beginning of the 'true' branch of the 'if' code
    la t2, if_end_5  # Load the address of the end of the 'if' code
    jr t2  # Jump to skip the 'false' branch of 'if' code
if_false_4:  # Beginning of the 'false' branch of the 'if' code
    la t1, string_val
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_6
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_7
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_8
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_9
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_10
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
if_end_5:  # End of the 'if' code
    # Load expression to be applied as a function
    la t1, fun_h  # Load variable 'h' (labmda term)
    li t2, 1
    # Before function call: save caller-saved registers
    addi sp, sp, -60  # Update stack pointer to make room for saved registers
    sw ra, 0(sp)
    sw a0, 4(sp)
    sw a1, 8(sp)
    sw a2, 12(sp)
    sw a3, 16(sp)
    sw a4, 20(sp)
    sw a5, 24(sp)
    sw a6, 28(sp)
    sw a7, 32(sp)
    sw t0, 36(sp)
    sw t2, 40(sp)
    sw t3, 44(sp)
    sw t4, 48(sp)
    sw t5, 52(sp)
    sw t6, 56(sp)
    mv a0, t2  # Load function call argument 1
    jalr ra, 0(t1)  # Function call
    # After function call
    mv t1, a0  # Copy function return value to target register
    # Restore caller-saved registers
    lw ra, 0(sp)
    lw a0, 4(sp)
    lw a1, 8(sp)
    lw a2, 12(sp)
    lw a3, 16(sp)
    lw a4, 20(sp)
    lw a5, 24(sp)
    lw a6, 28(sp)
    lw a7, 32(sp)
    lw t0, 36(sp)
    lw t2, 40(sp)
    lw t3, 44(sp)
    lw t4, 48(sp)
    lw t5, 52(sp)
    lw t6, 56(sp)
    addi sp, sp, 60  # Restore stack pointer after register restoration
    li t2, 42
    beq t1, t2, eq_true_11
    li t1, 0  # Comparison result is false
    j eq_end_12
eq_true_11:
    li t1, 1  # Comparison result is true
eq_end_12:
    addi t1, t1, -1
    beqz t1, assert_true  # Jump if assertion OK
    li a7, 93  # RARS syscall: Exit2
    li a0, 42  # Assertion violation exit code
    ecall
assert_true:
    # Load expression to be applied as a function
    la t1, fun_h  # Load variable 'h' (labmda term)
    li t2, 42
    # Before function call: save caller-saved registers
    addi sp, sp, -60  # Update stack pointer to make room for saved registers
    sw ra, 0(sp)
    sw a0, 4(sp)
    sw a1, 8(sp)
    sw a2, 12(sp)
    sw a3, 16(sp)
    sw a4, 20(sp)
    sw a5, 24(sp)
    sw a6, 28(sp)
    sw a7, 32(sp)
    sw t0, 36(sp)
    sw t2, 40(sp)
    sw t3, 44(sp)
    sw t4, 48(sp)
    sw t5, 52(sp)
    sw t6, 56(sp)
    mv a0, t2  # Load function call argument 1
    jalr ra, 0(t1)  # Function call
    # After function call
    mv t1, a0  # Copy function return value to target register
    # Restore caller-saved registers
    lw ra, 0(sp)
    lw a0, 4(sp)
    lw a1, 8(sp)
    lw a2, 12(sp)
    lw a3, 16(sp)
    lw a4, 20(sp)
    lw a5, 24(sp)
    lw a6, 28(sp)
    lw a7, 32(sp)
    lw t0, 36(sp)
    lw t2, 40(sp)
    lw t3, 44(sp)
    lw t4, 48(sp)
    lw t5, 52(sp)
    lw t6, 56(sp)
    addi sp, sp, 60  # Restore stack pointer after register restoration
    li t2, 1
    beq t1, t2, eq_true_16
    li t1, 0  # Comparison result is false
    j eq_end_17
eq_true_16:
    li t1, 1  # Comparison result is true
eq_end_17:
    bnez t1, if_true_13  # Jump when 'if' condition is true
    la t1, if_false_14  # Load the address of the 'false' branch of the 'if' code
    jr t1  # Jump to the 'false' branch of the 'if' code
if_true_13:  # Beginning of the 'true' branch of the 'if' code
    la t2, if_end_15  # Load the address of the end of the 'if' code
    jr t2  # Jump to skip the 'false' branch of 'if' code
if_false_14:  # Beginning of the 'false' branch of the 'if' code
    la t1, string_val_18
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_19
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_20
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_21
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_22
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    la t1, string_val_23
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    mv a0, t1  # Copy to a0 for printing
    li a7, 4  # RARS syscall: PrintString
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
    # Before system call: save registers
    addi sp, sp, -8  # Update stack pointer to make room for saved registers
    sw a7, 0(sp)
    sw a0, 4(sp)
    li a7, 11  # RARS syscall: PrintChar
    li a0, 10  # Character to print (newline)
    ecall
    # After system call: restore registers
    lw a7, 0(sp)
    lw a0, 4(sp)
    addi sp, sp, 8  # Restore stack pointer after register restoration
if_end_15:  # End of the 'if' code
    # Load expression to be applied as a function
    la t1, fun_h  # Load variable 'h' (labmda term)
    li t2, 42
    # Before function call: save caller-saved registers
    addi sp, sp, -60  # Update stack pointer to make room for saved registers
    sw ra, 0(sp)
    sw a0, 4(sp)
    sw a1, 8(sp)
    sw a2, 12(sp)
    sw a3, 16(sp)
    sw a4, 20(sp)
    sw a5, 24(sp)
    sw a6, 28(sp)
    sw a7, 32(sp)
    sw t0, 36(sp)
    sw t2, 40(sp)
    sw t3, 44(sp)
    sw t4, 48(sp)
    sw t5, 52(sp)
    sw t6, 56(sp)
    mv a0, t2  # Load function call argument 1
    jalr ra, 0(t1)  # Function call
    # After function call
    mv t1, a0  # Copy function return value to target register
    # Restore caller-saved registers
    lw ra, 0(sp)
    lw a0, 4(sp)
    lw a1, 8(sp)
    lw a2, 12(sp)
    lw a3, 16(sp)
    lw a4, 20(sp)
    lw a5, 24(sp)
    lw a6, 28(sp)
    lw a7, 32(sp)
    lw t0, 36(sp)
    lw t2, 40(sp)
    lw t3, 44(sp)
    lw t4, 48(sp)
    lw t5, 52(sp)
    lw t6, 56(sp)
    addi sp, sp, 60  # Restore stack pointer after register restoration
    li t2, 1
    beq t1, t2, eq_true_25
    li t1, 0  # Comparison result is false
    j eq_end_26
eq_true_25:
    li t1, 1  # Comparison result is true
eq_end_26:
    addi t1, t1, -1
    beqz t1, assert_true_24  # Jump if assertion OK
    li a7, 93  # RARS syscall: Exit2
    li a0, 42  # Assertion violation exit code
    ecall
assert_true_24:
    mv t0, t1  # Move 'let' scope result to 'let' target register
    li a7, 10  # RARS syscall: Exit
    ecall  # Successful exit with code 0


fun_f:  # Code for function 'f'
    # Function prologue begins here
    # Save callee-saved registers
    addi sp, sp, -48  # Update stack pointer to make room for saved registers
    sw fp, 0(sp)
    sw s1, 4(sp)
    sw s2, 8(sp)
    sw s3, 12(sp)
    sw s4, 16(sp)
    sw s5, 20(sp)
    sw s6, 24(sp)
    sw s7, 28(sp)
    sw s8, 32(sp)
    sw s9, 36(sp)
    sw s10, 40(sp)
    sw s11, 44(sp)
    addi fp, sp, 48  # Update frame pointer for the current function
    # End of function prologue.  Function body begins
    mv t0, a0  # Load variable 'x'
    li t1, 42
    blt t0, t1, less_true
    li t0, 0  # Comparison result is false
    j less_end
less_true:
    li t0, 1  # Comparison result is true
less_end:
    # End of function body.  Function epilogue begins
    mv a0, t0  # Move result of function into return value register
    # Restore callee-saved registers
    lw fp, 0(sp)
    lw s1, 4(sp)
    lw s2, 8(sp)
    lw s3, 12(sp)
    lw s4, 16(sp)
    lw s5, 20(sp)
    lw s6, 24(sp)
    lw s7, 28(sp)
    lw s8, 32(sp)
    lw s9, 36(sp)
    lw s10, 40(sp)
    lw s11, 44(sp)
    addi sp, sp, 48  # Restore stack pointer after register restoration
    jr ra  # End of function, return to caller
fun_g:  # Code for function 'g'
    # Function prologue begins here
    # Save callee-saved registers
    addi sp, sp, -48  # Update stack pointer to make room for saved registers
    sw fp, 0(sp)
    sw s1, 4(sp)
    sw s2, 8(sp)
    sw s3, 12(sp)
    sw s4, 16(sp)
    sw s5, 20(sp)
    sw s6, 24(sp)
    sw s7, 28(sp)
    sw s8, 32(sp)
    sw s9, 36(sp)
    sw s10, 40(sp)
    sw s11, 44(sp)
    addi fp, sp, 48  # Update frame pointer for the current function
    # End of function prologue.  Function body begins
    mv t0, a0  # Load variable 'b'
    bnez t0, if_true  # Jump when 'if' condition is true
    la t0, if_false  # Load the address of the 'false' branch of the 'if' code
    jr t0  # Jump to the 'false' branch of the 'if' code
if_true:  # Beginning of the 'true' branch of the 'if' code
    li t0, 42
    la t1, if_end  # Load the address of the end of the 'if' code
    jr t1  # Jump to skip the 'false' branch of 'if' code
if_false:  # Beginning of the 'false' branch of the 'if' code
    li t0, 1
if_end:  # End of the 'if' code
    # End of function body.  Function epilogue begins
    mv a0, t0  # Move result of function into return value register
    # Restore callee-saved registers
    lw fp, 0(sp)
    lw s1, 4(sp)
    lw s2, 8(sp)
    lw s3, 12(sp)
    lw s4, 16(sp)
    lw s5, 20(sp)
    lw s6, 24(sp)
    lw s7, 28(sp)
    lw s8, 32(sp)
    lw s9, 36(sp)
    lw s10, 40(sp)
    lw s11, 44(sp)
    addi sp, sp, 48  # Restore stack pointer after register restoration
    jr ra  # End of function, return to caller
fun_h:  # Code for function 'h'
    # Function prologue begins here
    # Save callee-saved registers
    addi sp, sp, -48  # Update stack pointer to make room for saved registers
    sw fp, 0(sp)
    sw s1, 4(sp)
    sw s2, 8(sp)
    sw s3, 12(sp)
    sw s4, 16(sp)
    sw s5, 20(sp)
    sw s6, 24(sp)
    sw s7, 28(sp)
    sw s8, 32(sp)
    sw s9, 36(sp)
    sw s10, 40(sp)
    sw s11, 44(sp)
    addi fp, sp, 48  # Update frame pointer for the current function
    # End of function prologue.  Function body begins
    # Load expression to be applied as a function
    la t0, fun_f  # Load variable 'f' (labmda term)
    mv t1, a0  # Load variable 'y'
    # Before function call: save caller-saved registers
    addi sp, sp, -60  # Update stack pointer to make room for saved registers
    sw ra, 0(sp)
    sw a0, 4(sp)
    sw a1, 8(sp)
    sw a2, 12(sp)
    sw a3, 16(sp)
    sw a4, 20(sp)
    sw a5, 24(sp)
    sw a6, 28(sp)
    sw a7, 32(sp)
    sw t1, 36(sp)
    sw t2, 40(sp)
    sw t3, 44(sp)
    sw t4, 48(sp)
    sw t5, 52(sp)
    sw t6, 56(sp)
    mv a0, t1  # Load function call argument 1
    jalr ra, 0(t0)  # Function call
    # After function call
    mv t0, a0  # Copy function return value to target register
    # Restore caller-saved registers
    lw ra, 0(sp)
    lw a0, 4(sp)
    lw a1, 8(sp)
    lw a2, 12(sp)
    lw a3, 16(sp)
    lw a4, 20(sp)
    lw a5, 24(sp)
    lw a6, 28(sp)
    lw a7, 32(sp)
    lw t1, 36(sp)
    lw t2, 40(sp)
    lw t3, 44(sp)
    lw t4, 48(sp)
    lw t5, 52(sp)
    lw t6, 56(sp)
    addi sp, sp, 60  # Restore stack pointer after register restoration
    bnez t0, if_true_0  # Jump when 'if' condition is true
    la t0, if_false_1  # Load the address of the 'false' branch of the 'if' code
    jr t0  # Jump to the 'false' branch of the 'if' code
if_true_0:  # Beginning of the 'true' branch of the 'if' code
    # Load expression to be applied as a function
    la t0, fun_g  # Load variable 'g' (labmda term)
    # Load expression to be applied as a function
    la t1, fun_f  # Load variable 'f' (labmda term)
    mv t2, a0  # Load variable 'y'
    # Before function call: save caller-saved registers
    addi sp, sp, -60  # Update stack pointer to make room for saved registers
    sw ra, 0(sp)
    sw a0, 4(sp)
    sw a1, 8(sp)
    sw a2, 12(sp)
    sw a3, 16(sp)
    sw a4, 20(sp)
    sw a5, 24(sp)
    sw a6, 28(sp)
    sw a7, 32(sp)
    sw t0, 36(sp)
    sw t2, 40(sp)
    sw t3, 44(sp)
    sw t4, 48(sp)
    sw t5, 52(sp)
    sw t6, 56(sp)
    mv a0, t2  # Load function call argument 1
    jalr ra, 0(t1)  # Function call
    # After function call
    mv t1, a0  # Copy function return value to target register
    # Restore caller-saved registers
    lw ra, 0(sp)
    lw a0, 4(sp)
    lw a1, 8(sp)
    lw a2, 12(sp)
    lw a3, 16(sp)
    lw a4, 20(sp)
    lw a5, 24(sp)
    lw a6, 28(sp)
    lw a7, 32(sp)
    lw t0, 36(sp)
    lw t2, 40(sp)
    lw t3, 44(sp)
    lw t4, 48(sp)
    lw t5, 52(sp)
    lw t6, 56(sp)
    addi sp, sp, 60  # Restore stack pointer after register restoration
    # Before function call: save caller-saved registers
    addi sp, sp, -60  # Update stack pointer to make room for saved registers
    sw ra, 0(sp)
    sw a0, 4(sp)
    sw a1, 8(sp)
    sw a2, 12(sp)
    sw a3, 16(sp)
    sw a4, 20(sp)
    sw a5, 24(sp)
    sw a6, 28(sp)
    sw a7, 32(sp)
    sw t1, 36(sp)
    sw t2, 40(sp)
    sw t3, 44(sp)
    sw t4, 48(sp)
    sw t5, 52(sp)
    sw t6, 56(sp)
    # Arg 1 is of type: bool, floats and integers are only accepted.
    jalr ra, 0(t0)  # Function call
    # After function call
    mv t0, a0  # Copy function return value to target register
    # Restore caller-saved registers
    lw ra, 0(sp)
    lw a0, 4(sp)
    lw a1, 8(sp)
    lw a2, 12(sp)
    lw a3, 16(sp)
    lw a4, 20(sp)
    lw a5, 24(sp)
    lw a6, 28(sp)
    lw a7, 32(sp)
    lw t1, 36(sp)
    lw t2, 40(sp)
    lw t3, 44(sp)
    lw t4, 48(sp)
    lw t5, 52(sp)
    lw t6, 56(sp)
    addi sp, sp, 60  # Restore stack pointer after register restoration
    la t1, if_end_2  # Load the address of the end of the 'if' code
    jr t1  # Jump to skip the 'false' branch of 'if' code
if_false_1:  # Beginning of the 'false' branch of the 'if' code
    # Load expression to be applied as a function
    la t0, fun_g  # Load variable 'g' (labmda term)
    li t1, 0  # Bool value 'False'
    # Before function call: save caller-saved registers
    addi sp, sp, -60  # Update stack pointer to make room for saved registers
    sw ra, 0(sp)
    sw a0, 4(sp)
    sw a1, 8(sp)
    sw a2, 12(sp)
    sw a3, 16(sp)
    sw a4, 20(sp)
    sw a5, 24(sp)
    sw a6, 28(sp)
    sw a7, 32(sp)
    sw t1, 36(sp)
    sw t2, 40(sp)
    sw t3, 44(sp)
    sw t4, 48(sp)
    sw t5, 52(sp)
    sw t6, 56(sp)
    # Arg 1 is of type: bool, floats and integers are only accepted.
    jalr ra, 0(t0)  # Function call
    # After function call
    mv t0, a0  # Copy function return value to target register
    # Restore caller-saved registers
    lw ra, 0(sp)
    lw a0, 4(sp)
    lw a1, 8(sp)
    lw a2, 12(sp)
    lw a3, 16(sp)
    lw a4, 20(sp)
    lw a5, 24(sp)
    lw a6, 28(sp)
    lw a7, 32(sp)
    lw t1, 36(sp)
    lw t2, 40(sp)
    lw t3, 44(sp)
    lw t4, 48(sp)
    lw t5, 52(sp)
    lw t6, 56(sp)
    addi sp, sp, 60  # Restore stack pointer after register restoration
if_end_2:  # End of the 'if' code
    # End of function body.  Function epilogue begins
    mv a0, t0  # Move result of function into return value register
    # Restore callee-saved registers
    lw fp, 0(sp)
    lw s1, 4(sp)
    lw s2, 8(sp)
    lw s3, 12(sp)
    lw s4, 16(sp)
    lw s5, 20(sp)
    lw s6, 24(sp)
    lw s7, 28(sp)
    lw s8, 32(sp)
    lw s9, 36(sp)
    lw s10, 40(sp)
    lw s11, 44(sp)
    addi sp, sp, 48  # Restore stack pointer after register restoration
    jr ra  # End of function, return to caller
